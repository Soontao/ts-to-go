// Code generated from ./lib/TypeScriptParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package typescript // TypeScriptParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type TypeScriptParser struct {
	TypeScriptParserBase
}

var TypeScriptParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func typescriptparserParserInit() {
	staticData := &TypeScriptParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", "';'",
		"','", "'='", "'?'", "':'", "'...'", "'.'", "'++'", "'--'", "'+'", "'-'",
		"'~'", "'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'>>>'", "'<'", "'>'",
		"'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", "'^'", "'|'",
		"'&&'", "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='",
		"'>>>='", "'&='", "'^='", "'|='", "'=>'", "'null'", "", "", "", "",
		"", "", "'break'", "'do'", "'instanceof'", "'typeof'", "'case'", "'else'",
		"'new'", "'var'", "'catch'", "'finally'", "'return'", "'void'", "'continue'",
		"'for'", "'switch'", "'while'", "'debugger'", "'function'", "'this'",
		"'with'", "'default'", "'if'", "'throw'", "'delete'", "'in'", "'try'",
		"'as'", "'from'", "'readonly'", "'async'", "'class'", "'enum'", "'extends'",
		"'super'", "'const'", "'export'", "'import'", "'implements'", "'let'",
		"'private'", "'public'", "'interface'", "'package'", "'protected'",
		"'static'", "'yield'", "'any'", "'number'", "'boolean'", "'string'",
		"'symbol'", "'type'", "'get'", "'set'", "'constructor'", "'namespace'",
		"'require'", "'module'", "'declare'", "'abstract'", "'is'", "'@'",
	}
	staticData.SymbolicNames = []string{
		"", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
		"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
		"TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign",
		"QuestionMark", "Colon", "Ellipsis", "Dot", "PlusPlus", "MinusMinus",
		"Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", "Modulus", "RightShiftArithmetic",
		"LeftShiftArithmetic", "RightShiftLogical", "LessThan", "MoreThan",
		"LessThanEquals", "GreaterThanEquals", "Equals_", "NotEquals", "IdentityEquals",
		"IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign",
		"DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign",
		"RightShiftArithmeticAssign", "RightShiftLogicalAssign", "BitAndAssign",
		"BitXorAssign", "BitOrAssign", "ARROW", "NullLiteral", "BooleanLiteral",
		"DecimalLiteral", "HexIntegerLiteral", "OctalIntegerLiteral", "OctalIntegerLiteral2",
		"BinaryIntegerLiteral", "Break", "Do", "Instanceof", "Typeof", "Case",
		"Else", "New", "Var", "Catch", "Finally", "Return", "Void", "Continue",
		"For", "Switch", "While", "Debugger", "Function_", "This", "With", "Default",
		"If", "Throw", "Delete", "In", "Try", "As", "From", "ReadOnly", "Async",
		"Class", "Enum", "Extends", "Super", "Const", "Export", "Import", "Implements",
		"Let", "Private", "Public", "Interface", "Package", "Protected", "Static",
		"Yield", "Any", "Number", "Boolean", "String", "Symbol", "TypeAlias",
		"Get", "Set", "Constructor", "Namespace", "Require", "Module", "Declare",
		"Abstract", "Is", "At", "Identifier", "StringLiteral", "BackTick", "WhiteSpaces",
		"LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter",
		"TemplateStringEscapeAtom", "TemplateStringStartExpression", "TemplateStringAtom",
	}
	staticData.RuleNames = []string{
		"initializer", "bindingPattern", "typeParameters", "typeParameterList",
		"typeParameter", "constraint", "typeArguments", "typeArgumentList",
		"typeArgument", "type_", "unionOrIntersectionOrPrimaryType", "primaryType",
		"predefinedType", "typeReference", "nestedTypeGeneric", "typeGeneric",
		"typeIncludeGeneric", "typeName", "objectType", "typeBody", "typeMemberList",
		"typeMember", "arrayType", "tupleType", "tupleElementTypes", "functionType",
		"constructorType", "typeQuery", "typeQueryExpression", "propertySignatur",
		"typeAnnotation", "callSignature", "parameterList", "requiredParameterList",
		"parameter", "optionalParameter", "restParameter", "requiredParameter",
		"accessibilityModifier", "identifierOrPattern", "constructSignature",
		"indexSignature", "methodSignature", "typeAliasDeclaration", "constructorDeclaration",
		"interfaceDeclaration", "interfaceExtendsClause", "classOrInterfaceTypeList",
		"enumDeclaration", "enumBody", "enumMemberList", "enumMember", "namespaceDeclaration",
		"namespaceName", "importAliasDeclaration", "decoratorList", "decorator",
		"decoratorMemberExpression", "decoratorCallExpression", "program", "sourceElement",
		"statement", "block", "statementList", "abstractDeclaration", "importStatement",
		"fromBlock", "multipleImportStatement", "exportStatement", "variableStatement",
		"variableDeclarationList", "variableDeclaration", "emptyStatement_",
		"expressionStatement", "ifStatement", "iterationStatement", "varModifier",
		"continueStatement", "breakStatement", "returnStatement", "yieldStatement",
		"withStatement", "switchStatement", "caseBlock", "caseClauses", "caseClause",
		"defaultClause", "labelledStatement", "throwStatement", "tryStatement",
		"catchProduction", "finallyProduction", "debuggerStatement", "functionDeclaration",
		"classDeclaration", "classHeritage", "classTail", "classExtendsClause",
		"implementsClause", "classElement", "propertyMemberDeclaration", "propertyMemberBase",
		"indexMemberDeclaration", "generatorMethod", "generatorFunctionDeclaration",
		"generatorBlock", "generatorDefinition", "iteratorBlock", "iteratorDefinition",
		"formalParameterList", "formalParameterArg", "lastFormalParameterArg",
		"functionBody", "sourceElements", "arrayLiteral", "elementList", "arrayElement",
		"objectLiteral", "propertyAssignment", "getAccessor", "setAccessor",
		"propertyName", "arguments", "argumentList", "argument", "expressionSequence",
		"functionExpressionDeclaration", "singleExpression", "asExpression",
		"arrowFunctionDeclaration", "arrowFunctionParameters", "arrowFunctionBody",
		"assignmentOperator", "literal", "templateStringLiteral", "templateStringAtom",
		"numericLiteral", "identifierName", "identifierOrKeyWord", "reservedWord",
		"keyword", "getter", "setter", "eos",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 134, 1687, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 1, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 3, 1, 294, 8, 1, 1, 2, 1, 2, 3, 2, 298, 8, 2, 1, 2, 1,
		2, 1, 3, 1, 3, 1, 3, 5, 3, 305, 8, 3, 10, 3, 12, 3, 308, 9, 3, 1, 4, 1,
		4, 3, 4, 312, 8, 4, 1, 4, 3, 4, 315, 8, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6,
		3, 6, 322, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 5, 7, 329, 8, 7, 10, 7,
		12, 7, 332, 9, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 341,
		8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5,
		10, 352, 8, 10, 10, 10, 12, 10, 355, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 3, 11, 375, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		5, 11, 381, 8, 11, 10, 11, 12, 11, 384, 9, 11, 1, 12, 1, 12, 1, 13, 1,
		13, 3, 13, 390, 8, 13, 1, 14, 1, 14, 3, 14, 394, 8, 14, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		3, 16, 409, 8, 16, 1, 17, 1, 17, 3, 17, 413, 8, 17, 1, 18, 1, 18, 3, 18,
		417, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 3, 19, 423, 8, 19, 1, 20, 1, 20,
		1, 20, 5, 20, 428, 8, 20, 10, 20, 12, 20, 431, 9, 20, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 440, 8, 21, 3, 21, 442, 8, 21, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24,
		1, 24, 5, 24, 456, 8, 24, 10, 24, 12, 24, 459, 9, 24, 1, 25, 3, 25, 462,
		8, 25, 1, 25, 1, 25, 3, 25, 466, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		26, 1, 26, 3, 26, 474, 8, 26, 1, 26, 1, 26, 3, 26, 478, 8, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 4, 28,
		491, 8, 28, 11, 28, 12, 28, 492, 1, 28, 1, 28, 3, 28, 497, 8, 28, 1, 29,
		3, 29, 500, 8, 29, 1, 29, 1, 29, 3, 29, 504, 8, 29, 1, 29, 3, 29, 507,
		8, 29, 1, 29, 1, 29, 3, 29, 511, 8, 29, 1, 30, 1, 30, 1, 30, 1, 31, 3,
		31, 517, 8, 31, 1, 31, 1, 31, 3, 31, 521, 8, 31, 1, 31, 1, 31, 3, 31, 525,
		8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 531, 8, 32, 10, 32, 12, 32, 534,
		9, 32, 1, 32, 1, 32, 3, 32, 538, 8, 32, 3, 32, 540, 8, 32, 1, 33, 1, 33,
		1, 33, 5, 33, 545, 8, 33, 10, 33, 12, 33, 548, 9, 33, 1, 34, 1, 34, 3,
		34, 552, 8, 34, 1, 35, 3, 35, 555, 8, 35, 1, 35, 3, 35, 558, 8, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 563, 8, 35, 1, 35, 3, 35, 566, 8, 35, 1, 35, 3,
		35, 569, 8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 574, 8, 36, 1, 37, 3, 37, 577,
		8, 37, 1, 37, 3, 37, 580, 8, 37, 1, 37, 1, 37, 3, 37, 584, 8, 37, 1, 38,
		1, 38, 1, 39, 1, 39, 3, 39, 590, 8, 39, 1, 40, 1, 40, 3, 40, 594, 8, 40,
		1, 40, 1, 40, 3, 40, 598, 8, 40, 1, 40, 1, 40, 3, 40, 602, 8, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 3, 42, 613, 8,
		42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 3, 43, 620, 8, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 44, 3, 44, 627, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 632,
		8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 640, 8, 44, 1,
		45, 3, 45, 643, 8, 45, 1, 45, 3, 45, 646, 8, 45, 1, 45, 1, 45, 1, 45, 3,
		45, 651, 8, 45, 1, 45, 3, 45, 654, 8, 45, 1, 45, 1, 45, 3, 45, 658, 8,
		45, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 5, 47, 666, 8, 47, 10, 47,
		12, 47, 669, 9, 47, 1, 48, 3, 48, 672, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		3, 48, 678, 8, 48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 684, 8, 49, 1, 50,
		1, 50, 1, 50, 5, 50, 689, 8, 50, 10, 50, 12, 50, 692, 9, 50, 1, 51, 1,
		51, 1, 51, 3, 51, 697, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 703, 8,
		52, 1, 52, 1, 52, 1, 53, 1, 53, 4, 53, 709, 8, 53, 11, 53, 12, 53, 710,
		1, 53, 5, 53, 714, 8, 53, 10, 53, 12, 53, 717, 9, 53, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 55, 4, 55, 725, 8, 55, 11, 55, 12, 55, 726, 1, 56,
		1, 56, 1, 56, 3, 56, 732, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 740, 8, 57, 1, 57, 1, 57, 1, 57, 5, 57, 745, 8, 57, 10, 57,
		12, 57, 748, 9, 57, 1, 58, 1, 58, 1, 58, 1, 59, 3, 59, 754, 8, 59, 1, 59,
		1, 59, 1, 60, 3, 60, 759, 8, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 792, 8, 61, 1, 62, 1, 62, 3, 62,
		796, 8, 62, 1, 62, 1, 62, 1, 63, 4, 63, 801, 8, 63, 11, 63, 12, 63, 802,
		1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 809, 8, 64, 1, 64, 1, 64, 1, 65, 1,
		65, 1, 65, 3, 65, 816, 8, 65, 1, 66, 1, 66, 3, 66, 820, 8, 66, 1, 66, 1,
		66, 3, 66, 824, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67,
		3, 67, 833, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 839, 8, 67, 10, 67,
		12, 67, 842, 9, 67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 848, 8, 68, 1, 68,
		1, 68, 3, 68, 852, 8, 68, 1, 69, 1, 69, 3, 69, 856, 8, 69, 1, 69, 1, 69,
		3, 69, 860, 8, 69, 1, 69, 3, 69, 863, 8, 69, 1, 69, 3, 69, 866, 8, 69,
		1, 69, 3, 69, 869, 8, 69, 1, 69, 1, 69, 3, 69, 873, 8, 69, 1, 69, 1, 69,
		3, 69, 877, 8, 69, 1, 69, 1, 69, 3, 69, 881, 8, 69, 3, 69, 883, 8, 69,
		1, 70, 1, 70, 1, 70, 5, 70, 888, 8, 70, 10, 70, 12, 70, 891, 9, 70, 1,
		71, 1, 71, 1, 71, 3, 71, 896, 8, 71, 1, 71, 3, 71, 899, 8, 71, 1, 71, 3,
		71, 902, 8, 71, 1, 71, 1, 71, 3, 71, 906, 8, 71, 1, 71, 3, 71, 909, 8,
		71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 3, 73, 916, 8, 73, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 925, 8, 74, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 944, 8, 75, 1, 75, 1, 75, 3, 75, 948,
		8, 75, 1, 75, 1, 75, 3, 75, 952, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 3, 75, 962, 8, 75, 1, 75, 1, 75, 3, 75, 966, 8,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75,
		977, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 3, 75, 990, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75,
		996, 8, 75, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 3, 77, 1003, 8, 77, 1, 77,
		1, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1010, 8, 78, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 79, 3, 79, 1017, 8, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 3, 80,
		1024, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 1042, 8, 83,
		1, 83, 1, 83, 3, 83, 1046, 8, 83, 3, 83, 1048, 8, 83, 1, 83, 1, 83, 1,
		84, 4, 84, 1053, 8, 84, 11, 84, 12, 84, 1054, 1, 85, 1, 85, 1, 85, 1, 85,
		3, 85, 1061, 8, 85, 1, 86, 1, 86, 1, 86, 3, 86, 1066, 8, 86, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89,
		1, 89, 3, 89, 1081, 8, 89, 1, 89, 3, 89, 1084, 8, 89, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 93,
		1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1106, 8, 93, 1,
		94, 3, 94, 1109, 8, 94, 1, 94, 1, 94, 3, 94, 1113, 8, 94, 3, 94, 1115,
		8, 94, 1, 94, 3, 94, 1118, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1123, 8,
		94, 1, 94, 1, 94, 1, 94, 1, 95, 3, 95, 1129, 8, 95, 1, 95, 3, 95, 1132,
		8, 95, 1, 96, 1, 96, 5, 96, 1136, 8, 96, 10, 96, 12, 96, 1139, 9, 96, 1,
		96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 3, 99,
		1151, 8, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1156, 8, 99, 1, 100, 1, 100, 1,
		100, 3, 100, 1161, 8, 100, 1, 100, 3, 100, 1164, 8, 100, 1, 100, 3, 100,
		1167, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 3, 100, 1179, 8, 100, 1, 100, 1, 100, 1, 100, 3, 100,
		1184, 8, 100, 1, 100, 3, 100, 1187, 8, 100, 1, 101, 3, 101, 1190, 8, 101,
		1, 101, 3, 101, 1193, 8, 101, 1, 101, 3, 101, 1196, 8, 101, 1, 101, 3,
		101, 1199, 8, 101, 1, 102, 1, 102, 1, 102, 1, 103, 3, 103, 1205, 8, 103,
		1, 103, 1, 103, 1, 103, 3, 103, 1210, 8, 103, 1, 103, 1, 103, 1, 103, 1,
		103, 1, 103, 1, 104, 1, 104, 1, 104, 3, 104, 1220, 8, 104, 1, 104, 1, 104,
		3, 104, 1224, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1,
		105, 1, 105, 1, 105, 5, 105, 1235, 8, 105, 10, 105, 12, 105, 1238, 9, 105,
		1, 105, 3, 105, 1241, 8, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1,
		107, 1, 107, 1, 107, 1, 107, 5, 107, 1252, 8, 107, 10, 107, 12, 107, 1255,
		9, 107, 1, 107, 3, 107, 1258, 8, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1,
		108, 1, 108, 1, 108, 3, 108, 1267, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 109, 1, 109, 1, 109, 5, 109, 1277, 8, 109, 10, 109, 12, 109,
		1280, 9, 109, 1, 109, 1, 109, 3, 109, 1284, 8, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 3, 109, 1291, 8, 109, 3, 109, 1293, 8, 109, 1, 110,
		3, 110, 1296, 8, 110, 1, 110, 3, 110, 1299, 8, 110, 1, 110, 1, 110, 3,
		110, 1303, 8, 110, 1, 110, 3, 110, 1306, 8, 110, 1, 110, 1, 110, 3, 110,
		1310, 8, 110, 1, 111, 1, 111, 1, 111, 3, 111, 1315, 8, 111, 1, 112, 3,
		112, 1318, 8, 112, 1, 113, 4, 113, 1321, 8, 113, 11, 113, 12, 113, 1322,
		1, 114, 1, 114, 3, 114, 1327, 8, 114, 1, 114, 1, 114, 1, 115, 1, 115, 4,
		115, 1333, 8, 115, 11, 115, 12, 115, 1334, 1, 115, 5, 115, 1338, 8, 115,
		10, 115, 12, 115, 1341, 9, 115, 1, 116, 3, 116, 1344, 8, 116, 1, 116, 1,
		116, 3, 116, 1348, 8, 116, 1, 116, 3, 116, 1351, 8, 116, 1, 117, 1, 117,
		1, 117, 1, 117, 5, 117, 1357, 8, 117, 10, 117, 12, 117, 1360, 9, 117, 1,
		117, 3, 117, 1363, 8, 117, 3, 117, 1365, 8, 117, 1, 117, 1, 117, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1384, 8, 118, 1, 119, 1,
		119, 1, 119, 1, 119, 3, 119, 1390, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1400, 8, 120, 1, 120, 3, 120, 1403,
		8, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121,
		3, 121, 1413, 8, 121, 1, 122, 1, 122, 1, 122, 3, 122, 1418, 8, 122, 3,
		122, 1420, 8, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 5, 123, 1427,
		8, 123, 10, 123, 12, 123, 1430, 9, 123, 1, 124, 3, 124, 1433, 8, 124, 1,
		124, 1, 124, 3, 124, 1437, 8, 124, 1, 125, 1, 125, 1, 125, 5, 125, 1442,
		8, 125, 10, 125, 12, 125, 1445, 9, 125, 1, 126, 1, 126, 3, 126, 1449, 8,
		126, 1, 126, 1, 126, 3, 126, 1453, 8, 126, 1, 126, 1, 126, 3, 126, 1457,
		8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 3, 127, 1469, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 3, 127, 1476, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 3, 127, 1503, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 1515, 8, 127, 3, 127, 1517,
		8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 3, 127, 1575, 8, 127, 1, 127, 1, 127, 1, 127, 3,
		127, 1580, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 5, 127, 1595, 8, 127, 10,
		127, 12, 127, 1598, 9, 127, 1, 128, 1, 128, 1, 128, 3, 128, 1603, 8, 128,
		1, 128, 3, 128, 1606, 8, 128, 1, 129, 3, 129, 1609, 8, 129, 1, 129, 1,
		129, 3, 129, 1613, 8, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130,
		3, 130, 1621, 8, 130, 1, 130, 3, 130, 1624, 8, 130, 1, 131, 1, 131, 1,
		131, 1, 131, 1, 131, 3, 131, 1631, 8, 131, 1, 132, 1, 132, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1641, 8, 133, 1, 134, 1, 134, 5,
		134, 1645, 8, 134, 10, 134, 12, 134, 1648, 9, 134, 1, 134, 1, 134, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1658, 8, 135, 1, 136, 1,
		136, 1, 137, 1, 137, 3, 137, 1664, 8, 137, 1, 138, 1, 138, 1, 139, 1, 139,
		1, 139, 3, 139, 1671, 8, 139, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1,
		142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 1685, 8, 143,
		1, 143, 0, 4, 20, 22, 114, 254, 144, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
		20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
		92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
		212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
		242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
		272, 274, 276, 278, 280, 282, 284, 286, 0, 15, 2, 0, 73, 73, 108, 112,
		1, 0, 11, 12, 2, 0, 101, 102, 105, 105, 2, 0, 109, 109, 111, 111, 3, 0,
		69, 69, 96, 96, 100, 100, 2, 0, 13, 13, 15, 15, 1, 0, 24, 26, 1, 0, 20,
		21, 1, 0, 27, 29, 1, 0, 30, 33, 1, 0, 34, 37, 1, 0, 43, 53, 1, 0, 57, 61,
		3, 0, 113, 113, 118, 118, 124, 124, 5, 0, 62, 87, 89, 107, 109, 111, 113,
		115, 118, 119, 1863, 0, 288, 1, 0, 0, 0, 2, 293, 1, 0, 0, 0, 4, 295, 1,
		0, 0, 0, 6, 301, 1, 0, 0, 0, 8, 314, 1, 0, 0, 0, 10, 316, 1, 0, 0, 0, 12,
		319, 1, 0, 0, 0, 14, 325, 1, 0, 0, 0, 16, 333, 1, 0, 0, 0, 18, 340, 1,
		0, 0, 0, 20, 342, 1, 0, 0, 0, 22, 374, 1, 0, 0, 0, 24, 385, 1, 0, 0, 0,
		26, 387, 1, 0, 0, 0, 28, 393, 1, 0, 0, 0, 30, 395, 1, 0, 0, 0, 32, 399,
		1, 0, 0, 0, 34, 412, 1, 0, 0, 0, 36, 414, 1, 0, 0, 0, 38, 420, 1, 0, 0,
		0, 40, 424, 1, 0, 0, 0, 42, 441, 1, 0, 0, 0, 44, 443, 1, 0, 0, 0, 46, 448,
		1, 0, 0, 0, 48, 452, 1, 0, 0, 0, 50, 461, 1, 0, 0, 0, 52, 471, 1, 0, 0,
		0, 54, 483, 1, 0, 0, 0, 56, 496, 1, 0, 0, 0, 58, 499, 1, 0, 0, 0, 60, 512,
		1, 0, 0, 0, 62, 516, 1, 0, 0, 0, 64, 539, 1, 0, 0, 0, 66, 541, 1, 0, 0,
		0, 68, 551, 1, 0, 0, 0, 70, 554, 1, 0, 0, 0, 72, 570, 1, 0, 0, 0, 74, 576,
		1, 0, 0, 0, 76, 585, 1, 0, 0, 0, 78, 589, 1, 0, 0, 0, 80, 591, 1, 0, 0,
		0, 82, 603, 1, 0, 0, 0, 84, 610, 1, 0, 0, 0, 86, 616, 1, 0, 0, 0, 88, 626,
		1, 0, 0, 0, 90, 642, 1, 0, 0, 0, 92, 659, 1, 0, 0, 0, 94, 662, 1, 0, 0,
		0, 96, 671, 1, 0, 0, 0, 98, 681, 1, 0, 0, 0, 100, 685, 1, 0, 0, 0, 102,
		693, 1, 0, 0, 0, 104, 698, 1, 0, 0, 0, 106, 706, 1, 0, 0, 0, 108, 718,
		1, 0, 0, 0, 110, 724, 1, 0, 0, 0, 112, 728, 1, 0, 0, 0, 114, 739, 1, 0,
		0, 0, 116, 749, 1, 0, 0, 0, 118, 753, 1, 0, 0, 0, 120, 758, 1, 0, 0, 0,
		122, 791, 1, 0, 0, 0, 124, 793, 1, 0, 0, 0, 126, 800, 1, 0, 0, 0, 128,
		804, 1, 0, 0, 0, 130, 812, 1, 0, 0, 0, 132, 819, 1, 0, 0, 0, 134, 832,
		1, 0, 0, 0, 136, 845, 1, 0, 0, 0, 138, 882, 1, 0, 0, 0, 140, 884, 1, 0,
		0, 0, 142, 895, 1, 0, 0, 0, 144, 910, 1, 0, 0, 0, 146, 912, 1, 0, 0, 0,
		148, 917, 1, 0, 0, 0, 150, 995, 1, 0, 0, 0, 152, 997, 1, 0, 0, 0, 154,
		999, 1, 0, 0, 0, 156, 1006, 1, 0, 0, 0, 158, 1013, 1, 0, 0, 0, 160, 1020,
		1, 0, 0, 0, 162, 1027, 1, 0, 0, 0, 164, 1033, 1, 0, 0, 0, 166, 1039, 1,
		0, 0, 0, 168, 1052, 1, 0, 0, 0, 170, 1056, 1, 0, 0, 0, 172, 1062, 1, 0,
		0, 0, 174, 1067, 1, 0, 0, 0, 176, 1071, 1, 0, 0, 0, 178, 1076, 1, 0, 0,
		0, 180, 1085, 1, 0, 0, 0, 182, 1091, 1, 0, 0, 0, 184, 1094, 1, 0, 0, 0,
		186, 1097, 1, 0, 0, 0, 188, 1108, 1, 0, 0, 0, 190, 1128, 1, 0, 0, 0, 192,
		1133, 1, 0, 0, 0, 194, 1142, 1, 0, 0, 0, 196, 1145, 1, 0, 0, 0, 198, 1155,
		1, 0, 0, 0, 200, 1186, 1, 0, 0, 0, 202, 1189, 1, 0, 0, 0, 204, 1200, 1,
		0, 0, 0, 206, 1204, 1, 0, 0, 0, 208, 1216, 1, 0, 0, 0, 210, 1230, 1, 0,
		0, 0, 212, 1244, 1, 0, 0, 0, 214, 1247, 1, 0, 0, 0, 216, 1261, 1, 0, 0,
		0, 218, 1292, 1, 0, 0, 0, 220, 1295, 1, 0, 0, 0, 222, 1311, 1, 0, 0, 0,
		224, 1317, 1, 0, 0, 0, 226, 1320, 1, 0, 0, 0, 228, 1324, 1, 0, 0, 0, 230,
		1330, 1, 0, 0, 0, 232, 1343, 1, 0, 0, 0, 234, 1352, 1, 0, 0, 0, 236, 1383,
		1, 0, 0, 0, 238, 1385, 1, 0, 0, 0, 240, 1395, 1, 0, 0, 0, 242, 1412, 1,
		0, 0, 0, 244, 1414, 1, 0, 0, 0, 246, 1423, 1, 0, 0, 0, 248, 1432, 1, 0,
		0, 0, 250, 1438, 1, 0, 0, 0, 252, 1446, 1, 0, 0, 0, 254, 1516, 1, 0, 0,
		0, 256, 1605, 1, 0, 0, 0, 258, 1608, 1, 0, 0, 0, 260, 1623, 1, 0, 0, 0,
		262, 1630, 1, 0, 0, 0, 264, 1632, 1, 0, 0, 0, 266, 1640, 1, 0, 0, 0, 268,
		1642, 1, 0, 0, 0, 270, 1657, 1, 0, 0, 0, 272, 1659, 1, 0, 0, 0, 274, 1663,
		1, 0, 0, 0, 276, 1665, 1, 0, 0, 0, 278, 1670, 1, 0, 0, 0, 280, 1672, 1,
		0, 0, 0, 282, 1674, 1, 0, 0, 0, 284, 1677, 1, 0, 0, 0, 286, 1684, 1, 0,
		0, 0, 288, 289, 5, 13, 0, 0, 289, 290, 3, 254, 127, 0, 290, 1, 1, 0, 0,
		0, 291, 294, 3, 228, 114, 0, 292, 294, 3, 234, 117, 0, 293, 291, 1, 0,
		0, 0, 293, 292, 1, 0, 0, 0, 294, 3, 1, 0, 0, 0, 295, 297, 5, 30, 0, 0,
		296, 298, 3, 6, 3, 0, 297, 296, 1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298,
		299, 1, 0, 0, 0, 299, 300, 5, 31, 0, 0, 300, 5, 1, 0, 0, 0, 301, 306, 3,
		8, 4, 0, 302, 303, 5, 12, 0, 0, 303, 305, 3, 8, 4, 0, 304, 302, 1, 0, 0,
		0, 305, 308, 1, 0, 0, 0, 306, 304, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307,
		7, 1, 0, 0, 0, 308, 306, 1, 0, 0, 0, 309, 311, 5, 124, 0, 0, 310, 312,
		3, 10, 5, 0, 311, 310, 1, 0, 0, 0, 311, 312, 1, 0, 0, 0, 312, 315, 1, 0,
		0, 0, 313, 315, 3, 4, 2, 0, 314, 309, 1, 0, 0, 0, 314, 313, 1, 0, 0, 0,
		315, 9, 1, 0, 0, 0, 316, 317, 5, 94, 0, 0, 317, 318, 3, 18, 9, 0, 318,
		11, 1, 0, 0, 0, 319, 321, 5, 30, 0, 0, 320, 322, 3, 14, 7, 0, 321, 320,
		1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0, 323, 324, 5, 31,
		0, 0, 324, 13, 1, 0, 0, 0, 325, 330, 3, 16, 8, 0, 326, 327, 5, 12, 0, 0,
		327, 329, 3, 16, 8, 0, 328, 326, 1, 0, 0, 0, 329, 332, 1, 0, 0, 0, 330,
		328, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 15, 1, 0, 0, 0, 332, 330, 1,
		0, 0, 0, 333, 334, 3, 18, 9, 0, 334, 17, 1, 0, 0, 0, 335, 341, 3, 20, 10,
		0, 336, 341, 3, 50, 25, 0, 337, 341, 3, 52, 26, 0, 338, 341, 3, 30, 15,
		0, 339, 341, 5, 125, 0, 0, 340, 335, 1, 0, 0, 0, 340, 336, 1, 0, 0, 0,
		340, 337, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 340, 339, 1, 0, 0, 0, 341,
		19, 1, 0, 0, 0, 342, 343, 6, 10, -1, 0, 343, 344, 3, 22, 11, 0, 344, 353,
		1, 0, 0, 0, 345, 346, 10, 3, 0, 0, 346, 347, 5, 40, 0, 0, 347, 352, 3,
		20, 10, 4, 348, 349, 10, 2, 0, 0, 349, 350, 5, 38, 0, 0, 350, 352, 3, 20,
		10, 3, 351, 345, 1, 0, 0, 0, 351, 348, 1, 0, 0, 0, 352, 355, 1, 0, 0, 0,
		353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 21, 1, 0, 0, 0, 355, 353,
		1, 0, 0, 0, 356, 357, 6, 11, -1, 0, 357, 358, 5, 6, 0, 0, 358, 359, 3,
		18, 9, 0, 359, 360, 5, 7, 0, 0, 360, 375, 1, 0, 0, 0, 361, 375, 3, 24,
		12, 0, 362, 375, 3, 26, 13, 0, 363, 375, 3, 36, 18, 0, 364, 365, 5, 4,
		0, 0, 365, 366, 3, 48, 24, 0, 366, 367, 5, 5, 0, 0, 367, 375, 1, 0, 0,
		0, 368, 375, 3, 54, 27, 0, 369, 375, 5, 80, 0, 0, 370, 371, 3, 26, 13,
		0, 371, 372, 5, 122, 0, 0, 372, 373, 3, 22, 11, 1, 373, 375, 1, 0, 0, 0,
		374, 356, 1, 0, 0, 0, 374, 361, 1, 0, 0, 0, 374, 362, 1, 0, 0, 0, 374,
		363, 1, 0, 0, 0, 374, 364, 1, 0, 0, 0, 374, 368, 1, 0, 0, 0, 374, 369,
		1, 0, 0, 0, 374, 370, 1, 0, 0, 0, 375, 382, 1, 0, 0, 0, 376, 377, 10, 5,
		0, 0, 377, 378, 4, 11, 3, 0, 378, 379, 5, 4, 0, 0, 379, 381, 5, 5, 0, 0,
		380, 376, 1, 0, 0, 0, 381, 384, 1, 0, 0, 0, 382, 380, 1, 0, 0, 0, 382,
		383, 1, 0, 0, 0, 383, 23, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0, 385, 386, 7,
		0, 0, 0, 386, 25, 1, 0, 0, 0, 387, 389, 3, 34, 17, 0, 388, 390, 3, 28,
		14, 0, 389, 388, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 27, 1, 0, 0, 0,
		391, 394, 3, 32, 16, 0, 392, 394, 3, 30, 15, 0, 393, 391, 1, 0, 0, 0, 393,
		392, 1, 0, 0, 0, 394, 29, 1, 0, 0, 0, 395, 396, 5, 30, 0, 0, 396, 397,
		3, 14, 7, 0, 397, 398, 5, 31, 0, 0, 398, 31, 1, 0, 0, 0, 399, 400, 5, 30,
		0, 0, 400, 401, 3, 14, 7, 0, 401, 402, 5, 30, 0, 0, 402, 408, 3, 14, 7,
		0, 403, 404, 5, 31, 0, 0, 404, 405, 3, 2, 1, 0, 405, 406, 5, 31, 0, 0,
		406, 409, 1, 0, 0, 0, 407, 409, 5, 27, 0, 0, 408, 403, 1, 0, 0, 0, 408,
		407, 1, 0, 0, 0, 409, 33, 1, 0, 0, 0, 410, 413, 5, 124, 0, 0, 411, 413,
		3, 106, 53, 0, 412, 410, 1, 0, 0, 0, 412, 411, 1, 0, 0, 0, 413, 35, 1,
		0, 0, 0, 414, 416, 5, 8, 0, 0, 415, 417, 3, 38, 19, 0, 416, 415, 1, 0,
		0, 0, 416, 417, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 5, 10, 0, 0,
		419, 37, 1, 0, 0, 0, 420, 422, 3, 40, 20, 0, 421, 423, 7, 1, 0, 0, 422,
		421, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423, 39, 1, 0, 0, 0, 424, 429, 3,
		42, 21, 0, 425, 426, 7, 1, 0, 0, 426, 428, 3, 42, 21, 0, 427, 425, 1, 0,
		0, 0, 428, 431, 1, 0, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0,
		430, 41, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 432, 442, 3, 58, 29, 0, 433,
		442, 3, 62, 31, 0, 434, 442, 3, 80, 40, 0, 435, 442, 3, 82, 41, 0, 436,
		439, 3, 84, 42, 0, 437, 438, 5, 54, 0, 0, 438, 440, 3, 18, 9, 0, 439, 437,
		1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 442, 1, 0, 0, 0, 441, 432, 1, 0,
		0, 0, 441, 433, 1, 0, 0, 0, 441, 434, 1, 0, 0, 0, 441, 435, 1, 0, 0, 0,
		441, 436, 1, 0, 0, 0, 442, 43, 1, 0, 0, 0, 443, 444, 3, 22, 11, 0, 444,
		445, 4, 22, 4, 0, 445, 446, 5, 4, 0, 0, 446, 447, 5, 5, 0, 0, 447, 45,
		1, 0, 0, 0, 448, 449, 5, 4, 0, 0, 449, 450, 3, 48, 24, 0, 450, 451, 5,
		5, 0, 0, 451, 47, 1, 0, 0, 0, 452, 457, 3, 18, 9, 0, 453, 454, 5, 12, 0,
		0, 454, 456, 3, 18, 9, 0, 455, 453, 1, 0, 0, 0, 456, 459, 1, 0, 0, 0, 457,
		455, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 49, 1, 0, 0, 0, 459, 457, 1,
		0, 0, 0, 460, 462, 3, 4, 2, 0, 461, 460, 1, 0, 0, 0, 461, 462, 1, 0, 0,
		0, 462, 463, 1, 0, 0, 0, 463, 465, 5, 6, 0, 0, 464, 466, 3, 64, 32, 0,
		465, 464, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467,
		468, 5, 7, 0, 0, 468, 469, 5, 54, 0, 0, 469, 470, 3, 18, 9, 0, 470, 51,
		1, 0, 0, 0, 471, 473, 5, 68, 0, 0, 472, 474, 3, 4, 2, 0, 473, 472, 1, 0,
		0, 0, 473, 474, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 477, 5, 6, 0, 0,
		476, 478, 3, 64, 32, 0, 477, 476, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478,
		479, 1, 0, 0, 0, 479, 480, 5, 7, 0, 0, 480, 481, 5, 54, 0, 0, 481, 482,
		3, 18, 9, 0, 482, 53, 1, 0, 0, 0, 483, 484, 5, 65, 0, 0, 484, 485, 3, 56,
		28, 0, 485, 55, 1, 0, 0, 0, 486, 497, 5, 124, 0, 0, 487, 488, 3, 274, 137,
		0, 488, 489, 5, 17, 0, 0, 489, 491, 1, 0, 0, 0, 490, 487, 1, 0, 0, 0, 491,
		492, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 494,
		1, 0, 0, 0, 494, 495, 3, 274, 137, 0, 495, 497, 1, 0, 0, 0, 496, 486, 1,
		0, 0, 0, 496, 490, 1, 0, 0, 0, 497, 57, 1, 0, 0, 0, 498, 500, 5, 90, 0,
		0, 499, 498, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501,
		503, 3, 242, 121, 0, 502, 504, 5, 14, 0, 0, 503, 502, 1, 0, 0, 0, 503,
		504, 1, 0, 0, 0, 504, 506, 1, 0, 0, 0, 505, 507, 3, 60, 30, 0, 506, 505,
		1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 510, 1, 0, 0, 0, 508, 509, 5, 54,
		0, 0, 509, 511, 3, 18, 9, 0, 510, 508, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0,
		511, 59, 1, 0, 0, 0, 512, 513, 5, 15, 0, 0, 513, 514, 3, 18, 9, 0, 514,
		61, 1, 0, 0, 0, 515, 517, 3, 4, 2, 0, 516, 515, 1, 0, 0, 0, 516, 517, 1,
		0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 520, 5, 6, 0, 0, 519, 521, 3, 64, 32,
		0, 520, 519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522,
		524, 5, 7, 0, 0, 523, 525, 3, 60, 30, 0, 524, 523, 1, 0, 0, 0, 524, 525,
		1, 0, 0, 0, 525, 63, 1, 0, 0, 0, 526, 540, 3, 72, 36, 0, 527, 532, 3, 68,
		34, 0, 528, 529, 5, 12, 0, 0, 529, 531, 3, 68, 34, 0, 530, 528, 1, 0, 0,
		0, 531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533,
		537, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 536, 5, 12, 0, 0, 536, 538,
		3, 72, 36, 0, 537, 535, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 540, 1,
		0, 0, 0, 539, 526, 1, 0, 0, 0, 539, 527, 1, 0, 0, 0, 540, 65, 1, 0, 0,
		0, 541, 546, 3, 74, 37, 0, 542, 543, 5, 12, 0, 0, 543, 545, 3, 74, 37,
		0, 544, 542, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546,
		547, 1, 0, 0, 0, 547, 67, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 552, 3,
		74, 37, 0, 550, 552, 3, 70, 35, 0, 551, 549, 1, 0, 0, 0, 551, 550, 1, 0,
		0, 0, 552, 69, 1, 0, 0, 0, 553, 555, 3, 110, 55, 0, 554, 553, 1, 0, 0,
		0, 554, 555, 1, 0, 0, 0, 555, 557, 1, 0, 0, 0, 556, 558, 3, 76, 38, 0,
		557, 556, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559,
		568, 3, 78, 39, 0, 560, 562, 5, 14, 0, 0, 561, 563, 3, 60, 30, 0, 562,
		561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 569, 1, 0, 0, 0, 564, 566,
		3, 60, 30, 0, 565, 564, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 567, 1,
		0, 0, 0, 567, 569, 3, 0, 0, 0, 568, 560, 1, 0, 0, 0, 568, 565, 1, 0, 0,
		0, 569, 71, 1, 0, 0, 0, 570, 571, 5, 16, 0, 0, 571, 573, 3, 254, 127, 0,
		572, 574, 3, 60, 30, 0, 573, 572, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574,
		73, 1, 0, 0, 0, 575, 577, 3, 110, 55, 0, 576, 575, 1, 0, 0, 0, 576, 577,
		1, 0, 0, 0, 577, 579, 1, 0, 0, 0, 578, 580, 3, 76, 38, 0, 579, 578, 1,
		0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 583, 3, 78, 39,
		0, 582, 584, 3, 60, 30, 0, 583, 582, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0,
		584, 75, 1, 0, 0, 0, 585, 586, 7, 2, 0, 0, 586, 77, 1, 0, 0, 0, 587, 590,
		3, 274, 137, 0, 588, 590, 3, 2, 1, 0, 589, 587, 1, 0, 0, 0, 589, 588, 1,
		0, 0, 0, 590, 79, 1, 0, 0, 0, 591, 593, 5, 68, 0, 0, 592, 594, 3, 4, 2,
		0, 593, 592, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595,
		597, 5, 6, 0, 0, 596, 598, 3, 64, 32, 0, 597, 596, 1, 0, 0, 0, 597, 598,
		1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 601, 5, 7, 0, 0, 600, 602, 3, 60,
		30, 0, 601, 600, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 81, 1, 0, 0, 0,
		603, 604, 5, 4, 0, 0, 604, 605, 5, 124, 0, 0, 605, 606, 5, 15, 0, 0, 606,
		607, 7, 3, 0, 0, 607, 608, 5, 5, 0, 0, 608, 609, 3, 60, 30, 0, 609, 83,
		1, 0, 0, 0, 610, 612, 3, 242, 121, 0, 611, 613, 5, 14, 0, 0, 612, 611,
		1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 615, 3, 62,
		31, 0, 615, 85, 1, 0, 0, 0, 616, 617, 5, 113, 0, 0, 617, 619, 5, 124, 0,
		0, 618, 620, 3, 4, 2, 0, 619, 618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620,
		621, 1, 0, 0, 0, 621, 622, 5, 13, 0, 0, 622, 623, 3, 18, 9, 0, 623, 624,
		5, 11, 0, 0, 624, 87, 1, 0, 0, 0, 625, 627, 3, 76, 38, 0, 626, 625, 1,
		0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 628, 1, 0, 0, 0, 628, 629, 5, 116,
		0, 0, 629, 631, 5, 6, 0, 0, 630, 632, 3, 218, 109, 0, 631, 630, 1, 0, 0,
		0, 631, 632, 1, 0, 0, 0, 632, 633, 1, 0, 0, 0, 633, 639, 5, 7, 0, 0, 634,
		635, 5, 8, 0, 0, 635, 636, 3, 224, 112, 0, 636, 637, 5, 10, 0, 0, 637,
		640, 1, 0, 0, 0, 638, 640, 5, 11, 0, 0, 639, 634, 1, 0, 0, 0, 639, 638,
		1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 89, 1, 0, 0, 0, 641, 643, 5, 97,
		0, 0, 642, 641, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 645, 1, 0, 0, 0,
		644, 646, 5, 120, 0, 0, 645, 644, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646,
		647, 1, 0, 0, 0, 647, 648, 5, 103, 0, 0, 648, 650, 5, 124, 0, 0, 649, 651,
		3, 4, 2, 0, 650, 649, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 653, 1, 0,
		0, 0, 652, 654, 3, 92, 46, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0,
		0, 654, 655, 1, 0, 0, 0, 655, 657, 3, 36, 18, 0, 656, 658, 5, 11, 0, 0,
		657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 91, 1, 0, 0, 0, 659, 660,
		5, 94, 0, 0, 660, 661, 3, 94, 47, 0, 661, 93, 1, 0, 0, 0, 662, 667, 3,
		26, 13, 0, 663, 664, 5, 12, 0, 0, 664, 666, 3, 26, 13, 0, 665, 663, 1,
		0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 667, 668, 1, 0, 0,
		0, 668, 95, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 670, 672, 5, 96, 0, 0, 671,
		670, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 674,
		5, 93, 0, 0, 674, 675, 5, 124, 0, 0, 675, 677, 5, 8, 0, 0, 676, 678, 3,
		98, 49, 0, 677, 676, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 1, 0,
		0, 0, 679, 680, 5, 10, 0, 0, 680, 97, 1, 0, 0, 0, 681, 683, 3, 100, 50,
		0, 682, 684, 5, 12, 0, 0, 683, 682, 1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684,
		99, 1, 0, 0, 0, 685, 690, 3, 102, 51, 0, 686, 687, 5, 12, 0, 0, 687, 689,
		3, 102, 51, 0, 688, 686, 1, 0, 0, 0, 689, 692, 1, 0, 0, 0, 690, 688, 1,
		0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 101, 1, 0, 0, 0, 692, 690, 1, 0, 0,
		0, 693, 696, 3, 242, 121, 0, 694, 695, 5, 13, 0, 0, 695, 697, 3, 254, 127,
		0, 696, 694, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 103, 1, 0, 0, 0, 698,
		699, 5, 117, 0, 0, 699, 700, 3, 106, 53, 0, 700, 702, 5, 8, 0, 0, 701,
		703, 3, 126, 63, 0, 702, 701, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 704,
		1, 0, 0, 0, 704, 705, 5, 10, 0, 0, 705, 105, 1, 0, 0, 0, 706, 715, 5, 124,
		0, 0, 707, 709, 5, 17, 0, 0, 708, 707, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0,
		710, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712,
		714, 5, 124, 0, 0, 713, 708, 1, 0, 0, 0, 714, 717, 1, 0, 0, 0, 715, 713,
		1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 107, 1, 0, 0, 0, 717, 715, 1, 0,
		0, 0, 718, 719, 5, 124, 0, 0, 719, 720, 5, 13, 0, 0, 720, 721, 3, 106,
		53, 0, 721, 722, 5, 11, 0, 0, 722, 109, 1, 0, 0, 0, 723, 725, 3, 112, 56,
		0, 724, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 724, 1, 0, 0, 0, 726,
		727, 1, 0, 0, 0, 727, 111, 1, 0, 0, 0, 728, 731, 5, 123, 0, 0, 729, 732,
		3, 114, 57, 0, 730, 732, 3, 116, 58, 0, 731, 729, 1, 0, 0, 0, 731, 730,
		1, 0, 0, 0, 732, 113, 1, 0, 0, 0, 733, 734, 6, 57, -1, 0, 734, 740, 5,
		124, 0, 0, 735, 736, 5, 6, 0, 0, 736, 737, 3, 254, 127, 0, 737, 738, 5,
		7, 0, 0, 738, 740, 1, 0, 0, 0, 739, 733, 1, 0, 0, 0, 739, 735, 1, 0, 0,
		0, 740, 746, 1, 0, 0, 0, 741, 742, 10, 2, 0, 0, 742, 743, 5, 17, 0, 0,
		743, 745, 3, 274, 137, 0, 744, 741, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746,
		744, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 115, 1, 0, 0, 0, 748, 746,
		1, 0, 0, 0, 749, 750, 3, 114, 57, 0, 750, 751, 3, 244, 122, 0, 751, 117,
		1, 0, 0, 0, 752, 754, 3, 226, 113, 0, 753, 752, 1, 0, 0, 0, 753, 754, 1,
		0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 756, 5, 0, 0, 1, 756, 119, 1, 0, 0,
		0, 757, 759, 5, 97, 0, 0, 758, 757, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759,
		760, 1, 0, 0, 0, 760, 761, 3, 122, 61, 0, 761, 121, 1, 0, 0, 0, 762, 792,
		3, 124, 62, 0, 763, 792, 3, 130, 65, 0, 764, 792, 3, 136, 68, 0, 765, 792,
		3, 144, 72, 0, 766, 792, 3, 128, 64, 0, 767, 792, 3, 188, 94, 0, 768, 792,
		3, 90, 45, 0, 769, 792, 3, 104, 52, 0, 770, 792, 3, 148, 74, 0, 771, 792,
		3, 150, 75, 0, 772, 792, 3, 154, 77, 0, 773, 792, 3, 156, 78, 0, 774, 792,
		3, 158, 79, 0, 775, 792, 3, 160, 80, 0, 776, 792, 3, 162, 81, 0, 777, 792,
		3, 174, 87, 0, 778, 792, 3, 164, 82, 0, 779, 792, 3, 176, 88, 0, 780, 792,
		3, 178, 89, 0, 781, 792, 3, 184, 92, 0, 782, 792, 3, 186, 93, 0, 783, 792,
		3, 258, 129, 0, 784, 792, 3, 208, 104, 0, 785, 792, 3, 138, 69, 0, 786,
		792, 3, 86, 43, 0, 787, 792, 3, 96, 48, 0, 788, 792, 3, 146, 73, 0, 789,
		790, 5, 97, 0, 0, 790, 792, 3, 122, 61, 0, 791, 762, 1, 0, 0, 0, 791, 763,
		1, 0, 0, 0, 791, 764, 1, 0, 0, 0, 791, 765, 1, 0, 0, 0, 791, 766, 1, 0,
		0, 0, 791, 767, 1, 0, 0, 0, 791, 768, 1, 0, 0, 0, 791, 769, 1, 0, 0, 0,
		791, 770, 1, 0, 0, 0, 791, 771, 1, 0, 0, 0, 791, 772, 1, 0, 0, 0, 791,
		773, 1, 0, 0, 0, 791, 774, 1, 0, 0, 0, 791, 775, 1, 0, 0, 0, 791, 776,
		1, 0, 0, 0, 791, 777, 1, 0, 0, 0, 791, 778, 1, 0, 0, 0, 791, 779, 1, 0,
		0, 0, 791, 780, 1, 0, 0, 0, 791, 781, 1, 0, 0, 0, 791, 782, 1, 0, 0, 0,
		791, 783, 1, 0, 0, 0, 791, 784, 1, 0, 0, 0, 791, 785, 1, 0, 0, 0, 791,
		786, 1, 0, 0, 0, 791, 787, 1, 0, 0, 0, 791, 788, 1, 0, 0, 0, 791, 789,
		1, 0, 0, 0, 792, 123, 1, 0, 0, 0, 793, 795, 5, 8, 0, 0, 794, 796, 3, 126,
		63, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0,
		797, 798, 5, 10, 0, 0, 798, 125, 1, 0, 0, 0, 799, 801, 3, 122, 61, 0, 800,
		799, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 802, 803,
		1, 0, 0, 0, 803, 127, 1, 0, 0, 0, 804, 808, 5, 121, 0, 0, 805, 806, 5,
		124, 0, 0, 806, 809, 3, 62, 31, 0, 807, 809, 3, 138, 69, 0, 808, 805, 1,
		0, 0, 0, 808, 807, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 811, 3, 286,
		143, 0, 811, 129, 1, 0, 0, 0, 812, 815, 5, 98, 0, 0, 813, 816, 3, 132,
		66, 0, 814, 816, 3, 108, 54, 0, 815, 813, 1, 0, 0, 0, 815, 814, 1, 0, 0,
		0, 816, 131, 1, 0, 0, 0, 817, 820, 5, 24, 0, 0, 818, 820, 3, 134, 67, 0,
		819, 817, 1, 0, 0, 0, 819, 818, 1, 0, 0, 0, 820, 823, 1, 0, 0, 0, 821,
		822, 5, 88, 0, 0, 822, 824, 3, 274, 137, 0, 823, 821, 1, 0, 0, 0, 823,
		824, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 826, 5, 89, 0, 0, 826, 827,
		5, 125, 0, 0, 827, 828, 3, 286, 143, 0, 828, 133, 1, 0, 0, 0, 829, 830,
		3, 274, 137, 0, 830, 831, 5, 12, 0, 0, 831, 833, 1, 0, 0, 0, 832, 829,
		1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 835, 5, 8,
		0, 0, 835, 840, 3, 274, 137, 0, 836, 837, 5, 12, 0, 0, 837, 839, 3, 274,
		137, 0, 838, 836, 1, 0, 0, 0, 839, 842, 1, 0, 0, 0, 840, 838, 1, 0, 0,
		0, 840, 841, 1, 0, 0, 0, 841, 843, 1, 0, 0, 0, 842, 840, 1, 0, 0, 0, 843,
		844, 5, 10, 0, 0, 844, 135, 1, 0, 0, 0, 845, 847, 5, 97, 0, 0, 846, 848,
		5, 82, 0, 0, 847, 846, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 851, 1, 0,
		0, 0, 849, 852, 3, 132, 66, 0, 850, 852, 3, 122, 61, 0, 851, 849, 1, 0,
		0, 0, 851, 850, 1, 0, 0, 0, 852, 137, 1, 0, 0, 0, 853, 855, 3, 2, 1, 0,
		854, 856, 3, 60, 30, 0, 855, 854, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856,
		857, 1, 0, 0, 0, 857, 859, 3, 0, 0, 0, 858, 860, 5, 11, 0, 0, 859, 858,
		1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 883, 1, 0, 0, 0, 861, 863, 3, 76,
		38, 0, 862, 861, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 865, 1, 0, 0, 0,
		864, 866, 3, 152, 76, 0, 865, 864, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866,
		868, 1, 0, 0, 0, 867, 869, 5, 90, 0, 0, 868, 867, 1, 0, 0, 0, 868, 869,
		1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 872, 3, 140, 70, 0, 871, 873, 5,
		11, 0, 0, 872, 871, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 883, 1, 0, 0,
		0, 874, 876, 5, 120, 0, 0, 875, 877, 3, 152, 76, 0, 876, 875, 1, 0, 0,
		0, 876, 877, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 3, 140, 70, 0,
		879, 881, 5, 11, 0, 0, 880, 879, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881,
		883, 1, 0, 0, 0, 882, 853, 1, 0, 0, 0, 882, 862, 1, 0, 0, 0, 882, 874,
		1, 0, 0, 0, 883, 139, 1, 0, 0, 0, 884, 889, 3, 142, 71, 0, 885, 886, 5,
		12, 0, 0, 886, 888, 3, 142, 71, 0, 887, 885, 1, 0, 0, 0, 888, 891, 1, 0,
		0, 0, 889, 887, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 141, 1, 0, 0, 0,
		891, 889, 1, 0, 0, 0, 892, 896, 3, 276, 138, 0, 893, 896, 3, 228, 114,
		0, 894, 896, 3, 234, 117, 0, 895, 892, 1, 0, 0, 0, 895, 893, 1, 0, 0, 0,
		895, 894, 1, 0, 0, 0, 896, 898, 1, 0, 0, 0, 897, 899, 3, 60, 30, 0, 898,
		897, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 901, 1, 0, 0, 0, 900, 902,
		3, 254, 127, 0, 901, 900, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 908, 1,
		0, 0, 0, 903, 905, 5, 13, 0, 0, 904, 906, 3, 4, 2, 0, 905, 904, 1, 0, 0,
		0, 905, 906, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 909, 3, 254, 127, 0,
		908, 903, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 143, 1, 0, 0, 0, 910,
		911, 5, 11, 0, 0, 911, 145, 1, 0, 0, 0, 912, 913, 4, 73, 6, 0, 913, 915,
		3, 250, 125, 0, 914, 916, 5, 11, 0, 0, 915, 914, 1, 0, 0, 0, 915, 916,
		1, 0, 0, 0, 916, 147, 1, 0, 0, 0, 917, 918, 5, 83, 0, 0, 918, 919, 5, 6,
		0, 0, 919, 920, 3, 250, 125, 0, 920, 921, 5, 7, 0, 0, 921, 924, 3, 122,
		61, 0, 922, 923, 5, 67, 0, 0, 923, 925, 3, 122, 61, 0, 924, 922, 1, 0,
		0, 0, 924, 925, 1, 0, 0, 0, 925, 149, 1, 0, 0, 0, 926, 927, 5, 63, 0, 0,
		927, 928, 3, 122, 61, 0, 928, 929, 5, 77, 0, 0, 929, 930, 5, 6, 0, 0, 930,
		931, 3, 250, 125, 0, 931, 932, 5, 7, 0, 0, 932, 933, 3, 286, 143, 0, 933,
		996, 1, 0, 0, 0, 934, 935, 5, 77, 0, 0, 935, 936, 5, 6, 0, 0, 936, 937,
		3, 250, 125, 0, 937, 938, 5, 7, 0, 0, 938, 939, 3, 122, 61, 0, 939, 996,
		1, 0, 0, 0, 940, 941, 5, 75, 0, 0, 941, 943, 5, 6, 0, 0, 942, 944, 3, 250,
		125, 0, 943, 942, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 945, 1, 0, 0,
		0, 945, 947, 5, 11, 0, 0, 946, 948, 3, 250, 125, 0, 947, 946, 1, 0, 0,
		0, 947, 948, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 951, 5, 11, 0, 0, 950,
		952, 3, 250, 125, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 953,
		1, 0, 0, 0, 953, 954, 5, 7, 0, 0, 954, 996, 3, 122, 61, 0, 955, 956, 5,
		75, 0, 0, 956, 957, 5, 6, 0, 0, 957, 958, 3, 152, 76, 0, 958, 959, 3, 140,
		70, 0, 959, 961, 5, 11, 0, 0, 960, 962, 3, 250, 125, 0, 961, 960, 1, 0,
		0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 5, 11, 0, 0,
		964, 966, 3, 250, 125, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966,
		967, 1, 0, 0, 0, 967, 968, 5, 7, 0, 0, 968, 969, 3, 122, 61, 0, 969, 996,
		1, 0, 0, 0, 970, 971, 5, 75, 0, 0, 971, 972, 5, 6, 0, 0, 972, 976, 3, 254,
		127, 0, 973, 977, 5, 86, 0, 0, 974, 975, 5, 124, 0, 0, 975, 977, 4, 75,
		7, 0, 976, 973, 1, 0, 0, 0, 976, 974, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0,
		978, 979, 3, 250, 125, 0, 979, 980, 5, 7, 0, 0, 980, 981, 3, 122, 61, 0,
		981, 996, 1, 0, 0, 0, 982, 983, 5, 75, 0, 0, 983, 984, 5, 6, 0, 0, 984,
		985, 3, 152, 76, 0, 985, 989, 3, 142, 71, 0, 986, 990, 5, 86, 0, 0, 987,
		988, 5, 124, 0, 0, 988, 990, 4, 75, 8, 0, 989, 986, 1, 0, 0, 0, 989, 987,
		1, 0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 992, 3, 250, 125, 0, 992, 993, 5,
		7, 0, 0, 993, 994, 3, 122, 61, 0, 994, 996, 1, 0, 0, 0, 995, 926, 1, 0,
		0, 0, 995, 934, 1, 0, 0, 0, 995, 940, 1, 0, 0, 0, 995, 955, 1, 0, 0, 0,
		995, 970, 1, 0, 0, 0, 995, 982, 1, 0, 0, 0, 996, 151, 1, 0, 0, 0, 997,
		998, 7, 4, 0, 0, 998, 153, 1, 0, 0, 0, 999, 1002, 5, 74, 0, 0, 1000, 1001,
		4, 77, 9, 0, 1001, 1003, 5, 124, 0, 0, 1002, 1000, 1, 0, 0, 0, 1002, 1003,
		1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1005, 3, 286, 143, 0, 1005, 155,
		1, 0, 0, 0, 1006, 1009, 5, 62, 0, 0, 1007, 1008, 4, 78, 10, 0, 1008, 1010,
		5, 124, 0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011,
		1, 0, 0, 0, 1011, 1012, 3, 286, 143, 0, 1012, 157, 1, 0, 0, 0, 1013, 1016,
		5, 72, 0, 0, 1014, 1015, 4, 79, 11, 0, 1015, 1017, 3, 250, 125, 0, 1016,
		1014, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018,
		1019, 3, 286, 143, 0, 1019, 159, 1, 0, 0, 0, 1020, 1023, 5, 107, 0, 0,
		1021, 1022, 4, 80, 12, 0, 1022, 1024, 3, 250, 125, 0, 1023, 1021, 1, 0,
		0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1026, 3, 286,
		143, 0, 1026, 161, 1, 0, 0, 0, 1027, 1028, 5, 81, 0, 0, 1028, 1029, 5,
		6, 0, 0, 1029, 1030, 3, 250, 125, 0, 1030, 1031, 5, 7, 0, 0, 1031, 1032,
		3, 122, 61, 0, 1032, 163, 1, 0, 0, 0, 1033, 1034, 5, 76, 0, 0, 1034, 1035,
		5, 6, 0, 0, 1035, 1036, 3, 250, 125, 0, 1036, 1037, 5, 7, 0, 0, 1037, 1038,
		3, 166, 83, 0, 1038, 165, 1, 0, 0, 0, 1039, 1041, 5, 8, 0, 0, 1040, 1042,
		3, 168, 84, 0, 1041, 1040, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1047,
		1, 0, 0, 0, 1043, 1045, 3, 172, 86, 0, 1044, 1046, 3, 168, 84, 0, 1045,
		1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1048, 1, 0, 0, 0, 1047,
		1043, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049,
		1050, 5, 10, 0, 0, 1050, 167, 1, 0, 0, 0, 1051, 1053, 3, 170, 85, 0, 1052,
		1051, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1052, 1, 0, 0, 0, 1054,
		1055, 1, 0, 0, 0, 1055, 169, 1, 0, 0, 0, 1056, 1057, 5, 66, 0, 0, 1057,
		1058, 3, 250, 125, 0, 1058, 1060, 5, 15, 0, 0, 1059, 1061, 3, 126, 63,
		0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 171, 1, 0, 0,
		0, 1062, 1063, 5, 82, 0, 0, 1063, 1065, 5, 15, 0, 0, 1064, 1066, 3, 126,
		63, 0, 1065, 1064, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 173, 1, 0,
		0, 0, 1067, 1068, 5, 124, 0, 0, 1068, 1069, 5, 15, 0, 0, 1069, 1070, 3,
		122, 61, 0, 1070, 175, 1, 0, 0, 0, 1071, 1072, 5, 84, 0, 0, 1072, 1073,
		4, 88, 13, 0, 1073, 1074, 3, 250, 125, 0, 1074, 1075, 3, 286, 143, 0, 1075,
		177, 1, 0, 0, 0, 1076, 1077, 5, 87, 0, 0, 1077, 1083, 3, 124, 62, 0, 1078,
		1080, 3, 180, 90, 0, 1079, 1081, 3, 182, 91, 0, 1080, 1079, 1, 0, 0, 0,
		1080, 1081, 1, 0, 0, 0, 1081, 1084, 1, 0, 0, 0, 1082, 1084, 3, 182, 91,
		0, 1083, 1078, 1, 0, 0, 0, 1083, 1082, 1, 0, 0, 0, 1084, 179, 1, 0, 0,
		0, 1085, 1086, 5, 70, 0, 0, 1086, 1087, 5, 6, 0, 0, 1087, 1088, 5, 124,
		0, 0, 1088, 1089, 5, 7, 0, 0, 1089, 1090, 3, 124, 62, 0, 1090, 181, 1,
		0, 0, 0, 1091, 1092, 5, 71, 0, 0, 1092, 1093, 3, 124, 62, 0, 1093, 183,
		1, 0, 0, 0, 1094, 1095, 5, 78, 0, 0, 1095, 1096, 3, 286, 143, 0, 1096,
		185, 1, 0, 0, 0, 1097, 1098, 5, 79, 0, 0, 1098, 1099, 5, 124, 0, 0, 1099,
		1105, 3, 62, 31, 0, 1100, 1101, 5, 8, 0, 0, 1101, 1102, 3, 224, 112, 0,
		1102, 1103, 5, 10, 0, 0, 1103, 1106, 1, 0, 0, 0, 1104, 1106, 5, 11, 0,
		0, 1105, 1100, 1, 0, 0, 0, 1105, 1104, 1, 0, 0, 0, 1106, 187, 1, 0, 0,
		0, 1107, 1109, 3, 110, 55, 0, 1108, 1107, 1, 0, 0, 0, 1108, 1109, 1, 0,
		0, 0, 1109, 1114, 1, 0, 0, 0, 1110, 1112, 5, 97, 0, 0, 1111, 1113, 5, 82,
		0, 0, 1112, 1111, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0, 1113, 1115, 1, 0,
		0, 0, 1114, 1110, 1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1117, 1, 0,
		0, 0, 1116, 1118, 5, 121, 0, 0, 1117, 1116, 1, 0, 0, 0, 1117, 1118, 1,
		0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1120, 5, 92, 0, 0, 1120, 1122, 5,
		124, 0, 0, 1121, 1123, 3, 4, 2, 0, 1122, 1121, 1, 0, 0, 0, 1122, 1123,
		1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 1125, 3, 190, 95, 0, 1125, 1126,
		3, 192, 96, 0, 1126, 189, 1, 0, 0, 0, 1127, 1129, 3, 194, 97, 0, 1128,
		1127, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1131, 1, 0, 0, 0, 1130,
		1132, 3, 196, 98, 0, 1131, 1130, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132,
		191, 1, 0, 0, 0, 1133, 1137, 5, 8, 0, 0, 1134, 1136, 3, 198, 99, 0, 1135,
		1134, 1, 0, 0, 0, 1136, 1139, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 1137,
		1138, 1, 0, 0, 0, 1138, 1140, 1, 0, 0, 0, 1139, 1137, 1, 0, 0, 0, 1140,
		1141, 5, 10, 0, 0, 1141, 193, 1, 0, 0, 0, 1142, 1143, 5, 94, 0, 0, 1143,
		1144, 3, 26, 13, 0, 1144, 195, 1, 0, 0, 0, 1145, 1146, 5, 99, 0, 0, 1146,
		1147, 3, 94, 47, 0, 1147, 197, 1, 0, 0, 0, 1148, 1156, 3, 88, 44, 0, 1149,
		1151, 3, 110, 55, 0, 1150, 1149, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151,
		1152, 1, 0, 0, 0, 1152, 1156, 3, 200, 100, 0, 1153, 1156, 3, 204, 102,
		0, 1154, 1156, 3, 122, 61, 0, 1155, 1148, 1, 0, 0, 0, 1155, 1150, 1, 0,
		0, 0, 1155, 1153, 1, 0, 0, 0, 1155, 1154, 1, 0, 0, 0, 1156, 199, 1, 0,
		0, 0, 1157, 1158, 3, 202, 101, 0, 1158, 1160, 3, 242, 121, 0, 1159, 1161,
		5, 14, 0, 0, 1160, 1159, 1, 0, 0, 0, 1160, 1161, 1, 0, 0, 0, 1161, 1163,
		1, 0, 0, 0, 1162, 1164, 3, 60, 30, 0, 1163, 1162, 1, 0, 0, 0, 1163, 1164,
		1, 0, 0, 0, 1164, 1166, 1, 0, 0, 0, 1165, 1167, 3, 0, 0, 0, 1166, 1165,
		1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169,
		5, 11, 0, 0, 1169, 1187, 1, 0, 0, 0, 1170, 1171, 3, 202, 101, 0, 1171,
		1172, 3, 242, 121, 0, 1172, 1178, 3, 62, 31, 0, 1173, 1174, 5, 8, 0, 0,
		1174, 1175, 3, 224, 112, 0, 1175, 1176, 5, 10, 0, 0, 1176, 1179, 1, 0,
		0, 0, 1177, 1179, 5, 11, 0, 0, 1178, 1173, 1, 0, 0, 0, 1178, 1177, 1, 0,
		0, 0, 1179, 1187, 1, 0, 0, 0, 1180, 1183, 3, 202, 101, 0, 1181, 1184, 3,
		238, 119, 0, 1182, 1184, 3, 240, 120, 0, 1183, 1181, 1, 0, 0, 0, 1183,
		1182, 1, 0, 0, 0, 1184, 1187, 1, 0, 0, 0, 1185, 1187, 3, 128, 64, 0, 1186,
		1157, 1, 0, 0, 0, 1186, 1170, 1, 0, 0, 0, 1186, 1180, 1, 0, 0, 0, 1186,
		1185, 1, 0, 0, 0, 1187, 201, 1, 0, 0, 0, 1188, 1190, 3, 76, 38, 0, 1189,
		1188, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 1192, 1, 0, 0, 0, 1191,
		1193, 5, 91, 0, 0, 1192, 1191, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193,
		1195, 1, 0, 0, 0, 1194, 1196, 5, 106, 0, 0, 1195, 1194, 1, 0, 0, 0, 1195,
		1196, 1, 0, 0, 0, 1196, 1198, 1, 0, 0, 0, 1197, 1199, 5, 90, 0, 0, 1198,
		1197, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 203, 1, 0, 0, 0, 1200,
		1201, 3, 82, 41, 0, 1201, 1202, 5, 11, 0, 0, 1202, 205, 1, 0, 0, 0, 1203,
		1205, 5, 24, 0, 0, 1204, 1203, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205,
		1206, 1, 0, 0, 0, 1206, 1207, 5, 124, 0, 0, 1207, 1209, 5, 6, 0, 0, 1208,
		1210, 3, 218, 109, 0, 1209, 1208, 1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210,
		1211, 1, 0, 0, 0, 1211, 1212, 5, 7, 0, 0, 1212, 1213, 5, 8, 0, 0, 1213,
		1214, 3, 224, 112, 0, 1214, 1215, 5, 10, 0, 0, 1215, 207, 1, 0, 0, 0, 1216,
		1217, 5, 79, 0, 0, 1217, 1219, 5, 24, 0, 0, 1218, 1220, 5, 124, 0, 0, 1219,
		1218, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221,
		1223, 5, 6, 0, 0, 1222, 1224, 3, 218, 109, 0, 1223, 1222, 1, 0, 0, 0, 1223,
		1224, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1226, 5, 7, 0, 0, 1226,
		1227, 5, 8, 0, 0, 1227, 1228, 3, 224, 112, 0, 1228, 1229, 5, 10, 0, 0,
		1229, 209, 1, 0, 0, 0, 1230, 1231, 5, 8, 0, 0, 1231, 1236, 3, 212, 106,
		0, 1232, 1233, 5, 12, 0, 0, 1233, 1235, 3, 212, 106, 0, 1234, 1232, 1,
		0, 0, 0, 1235, 1238, 1, 0, 0, 0, 1236, 1234, 1, 0, 0, 0, 1236, 1237, 1,
		0, 0, 0, 1237, 1240, 1, 0, 0, 0, 1238, 1236, 1, 0, 0, 0, 1239, 1241, 5,
		12, 0, 0, 1240, 1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 1,
		0, 0, 0, 1242, 1243, 5, 10, 0, 0, 1243, 211, 1, 0, 0, 0, 1244, 1245, 5,
		24, 0, 0, 1245, 1246, 3, 216, 108, 0, 1246, 213, 1, 0, 0, 0, 1247, 1248,
		5, 8, 0, 0, 1248, 1253, 3, 216, 108, 0, 1249, 1250, 5, 12, 0, 0, 1250,
		1252, 3, 216, 108, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1255, 1, 0, 0, 0, 1253,
		1251, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1257, 1, 0, 0, 0, 1255,
		1253, 1, 0, 0, 0, 1256, 1258, 5, 12, 0, 0, 1257, 1256, 1, 0, 0, 0, 1257,
		1258, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1260, 5, 10, 0, 0, 1260,
		215, 1, 0, 0, 0, 1261, 1262, 5, 4, 0, 0, 1262, 1263, 3, 254, 127, 0, 1263,
		1264, 5, 5, 0, 0, 1264, 1266, 5, 6, 0, 0, 1265, 1267, 3, 218, 109, 0, 1266,
		1265, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268,
		1269, 5, 7, 0, 0, 1269, 1270, 5, 8, 0, 0, 1270, 1271, 3, 224, 112, 0, 1271,
		1272, 5, 10, 0, 0, 1272, 217, 1, 0, 0, 0, 1273, 1278, 3, 220, 110, 0, 1274,
		1275, 5, 12, 0, 0, 1275, 1277, 3, 220, 110, 0, 1276, 1274, 1, 0, 0, 0,
		1277, 1280, 1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0,
		1279, 1283, 1, 0, 0, 0, 1280, 1278, 1, 0, 0, 0, 1281, 1282, 5, 12, 0, 0,
		1282, 1284, 3, 222, 111, 0, 1283, 1281, 1, 0, 0, 0, 1283, 1284, 1, 0, 0,
		0, 1284, 1293, 1, 0, 0, 0, 1285, 1293, 3, 222, 111, 0, 1286, 1293, 3, 228,
		114, 0, 1287, 1290, 3, 234, 117, 0, 1288, 1289, 5, 15, 0, 0, 1289, 1291,
		3, 218, 109, 0, 1290, 1288, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1293,
		1, 0, 0, 0, 1292, 1273, 1, 0, 0, 0, 1292, 1285, 1, 0, 0, 0, 1292, 1286,
		1, 0, 0, 0, 1292, 1287, 1, 0, 0, 0, 1293, 219, 1, 0, 0, 0, 1294, 1296,
		3, 112, 56, 0, 1295, 1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1298,
		1, 0, 0, 0, 1297, 1299, 3, 76, 38, 0, 1298, 1297, 1, 0, 0, 0, 1298, 1299,
		1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1302, 3, 276, 138, 0, 1301, 1303,
		5, 14, 0, 0, 1302, 1301, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1305,
		1, 0, 0, 0, 1304, 1306, 3, 60, 30, 0, 1305, 1304, 1, 0, 0, 0, 1305, 1306,
		1, 0, 0, 0, 1306, 1309, 1, 0, 0, 0, 1307, 1308, 5, 13, 0, 0, 1308, 1310,
		3, 254, 127, 0, 1309, 1307, 1, 0, 0, 0, 1309, 1310, 1, 0, 0, 0, 1310, 221,
		1, 0, 0, 0, 1311, 1312, 5, 16, 0, 0, 1312, 1314, 5, 124, 0, 0, 1313, 1315,
		3, 60, 30, 0, 1314, 1313, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 223,
		1, 0, 0, 0, 1316, 1318, 3, 226, 113, 0, 1317, 1316, 1, 0, 0, 0, 1317, 1318,
		1, 0, 0, 0, 1318, 225, 1, 0, 0, 0, 1319, 1321, 3, 120, 60, 0, 1320, 1319,
		1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1320, 1, 0, 0, 0, 1322, 1323,
		1, 0, 0, 0, 1323, 227, 1, 0, 0, 0, 1324, 1326, 5, 4, 0, 0, 1325, 1327,
		3, 230, 115, 0, 1326, 1325, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1328,
		1, 0, 0, 0, 1328, 1329, 5, 5, 0, 0, 1329, 229, 1, 0, 0, 0, 1330, 1339,
		3, 232, 116, 0, 1331, 1333, 5, 12, 0, 0, 1332, 1331, 1, 0, 0, 0, 1333,
		1334, 1, 0, 0, 0, 1334, 1332, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335,
		1336, 1, 0, 0, 0, 1336, 1338, 3, 232, 116, 0, 1337, 1332, 1, 0, 0, 0, 1338,
		1341, 1, 0, 0, 0, 1339, 1337, 1, 0, 0, 0, 1339, 1340, 1, 0, 0, 0, 1340,
		231, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1342, 1344, 5, 16, 0, 0, 1343,
		1342, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1347, 1, 0, 0, 0, 1345,
		1348, 3, 254, 127, 0, 1346, 1348, 5, 124, 0, 0, 1347, 1345, 1, 0, 0, 0,
		1347, 1346, 1, 0, 0, 0, 1348, 1350, 1, 0, 0, 0, 1349, 1351, 5, 12, 0, 0,
		1350, 1349, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 233, 1, 0, 0, 0,
		1352, 1364, 5, 8, 0, 0, 1353, 1358, 3, 236, 118, 0, 1354, 1355, 5, 12,
		0, 0, 1355, 1357, 3, 236, 118, 0, 1356, 1354, 1, 0, 0, 0, 1357, 1360, 1,
		0, 0, 0, 1358, 1356, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 1362, 1,
		0, 0, 0, 1360, 1358, 1, 0, 0, 0, 1361, 1363, 5, 12, 0, 0, 1362, 1361, 1,
		0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363, 1365, 1, 0, 0, 0, 1364, 1353, 1,
		0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 1366, 1, 0, 0, 0, 1366, 1367, 5,
		10, 0, 0, 1367, 235, 1, 0, 0, 0, 1368, 1369, 3, 242, 121, 0, 1369, 1370,
		7, 5, 0, 0, 1370, 1371, 3, 254, 127, 0, 1371, 1384, 1, 0, 0, 0, 1372, 1373,
		5, 4, 0, 0, 1373, 1374, 3, 254, 127, 0, 1374, 1375, 5, 5, 0, 0, 1375, 1376,
		5, 15, 0, 0, 1376, 1377, 3, 254, 127, 0, 1377, 1384, 1, 0, 0, 0, 1378,
		1384, 3, 238, 119, 0, 1379, 1384, 3, 240, 120, 0, 1380, 1384, 3, 206, 103,
		0, 1381, 1384, 3, 276, 138, 0, 1382, 1384, 3, 72, 36, 0, 1383, 1368, 1,
		0, 0, 0, 1383, 1372, 1, 0, 0, 0, 1383, 1378, 1, 0, 0, 0, 1383, 1379, 1,
		0, 0, 0, 1383, 1380, 1, 0, 0, 0, 1383, 1381, 1, 0, 0, 0, 1383, 1382, 1,
		0, 0, 0, 1384, 237, 1, 0, 0, 0, 1385, 1386, 3, 282, 141, 0, 1386, 1387,
		5, 6, 0, 0, 1387, 1389, 5, 7, 0, 0, 1388, 1390, 3, 60, 30, 0, 1389, 1388,
		1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 1392,
		5, 8, 0, 0, 1392, 1393, 3, 224, 112, 0, 1393, 1394, 5, 10, 0, 0, 1394,
		239, 1, 0, 0, 0, 1395, 1396, 3, 284, 142, 0, 1396, 1399, 5, 6, 0, 0, 1397,
		1400, 5, 124, 0, 0, 1398, 1400, 3, 2, 1, 0, 1399, 1397, 1, 0, 0, 0, 1399,
		1398, 1, 0, 0, 0, 1400, 1402, 1, 0, 0, 0, 1401, 1403, 3, 60, 30, 0, 1402,
		1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404,
		1405, 5, 7, 0, 0, 1405, 1406, 5, 8, 0, 0, 1406, 1407, 3, 224, 112, 0, 1407,
		1408, 5, 10, 0, 0, 1408, 241, 1, 0, 0, 0, 1409, 1413, 3, 274, 137, 0, 1410,
		1413, 5, 125, 0, 0, 1411, 1413, 3, 272, 136, 0, 1412, 1409, 1, 0, 0, 0,
		1412, 1410, 1, 0, 0, 0, 1412, 1411, 1, 0, 0, 0, 1413, 243, 1, 0, 0, 0,
		1414, 1419, 5, 6, 0, 0, 1415, 1417, 3, 246, 123, 0, 1416, 1418, 5, 12,
		0, 0, 1417, 1416, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1420, 1, 0,
		0, 0, 1419, 1415, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421, 1, 0,
		0, 0, 1421, 1422, 5, 7, 0, 0, 1422, 245, 1, 0, 0, 0, 1423, 1428, 3, 248,
		124, 0, 1424, 1425, 5, 12, 0, 0, 1425, 1427, 3, 248, 124, 0, 1426, 1424,
		1, 0, 0, 0, 1427, 1430, 1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1428, 1429,
		1, 0, 0, 0, 1429, 247, 1, 0, 0, 0, 1430, 1428, 1, 0, 0, 0, 1431, 1433,
		5, 16, 0, 0, 1432, 1431, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1436,
		1, 0, 0, 0, 1434, 1437, 3, 254, 127, 0, 1435, 1437, 5, 124, 0, 0, 1436,
		1434, 1, 0, 0, 0, 1436, 1435, 1, 0, 0, 0, 1437, 249, 1, 0, 0, 0, 1438,
		1443, 3, 254, 127, 0, 1439, 1440, 5, 12, 0, 0, 1440, 1442, 3, 254, 127,
		0, 1441, 1439, 1, 0, 0, 0, 1442, 1445, 1, 0, 0, 0, 1443, 1441, 1, 0, 0,
		0, 1443, 1444, 1, 0, 0, 0, 1444, 251, 1, 0, 0, 0, 1445, 1443, 1, 0, 0,
		0, 1446, 1448, 5, 79, 0, 0, 1447, 1449, 5, 124, 0, 0, 1448, 1447, 1, 0,
		0, 0, 1448, 1449, 1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1452, 5, 6,
		0, 0, 1451, 1453, 3, 218, 109, 0, 1452, 1451, 1, 0, 0, 0, 1452, 1453, 1,
		0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1456, 5, 7, 0, 0, 1455, 1457, 3,
		60, 30, 0, 1456, 1455, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1458,
		1, 0, 0, 0, 1458, 1459, 5, 8, 0, 0, 1459, 1460, 3, 224, 112, 0, 1460, 1461,
		5, 10, 0, 0, 1461, 253, 1, 0, 0, 0, 1462, 1463, 6, 127, -1, 0, 1463, 1517,
		3, 252, 126, 0, 1464, 1517, 3, 258, 129, 0, 1465, 1466, 5, 68, 0, 0, 1466,
		1468, 3, 254, 127, 0, 1467, 1469, 3, 12, 6, 0, 1468, 1467, 1, 0, 0, 0,
		1468, 1469, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1471, 3, 244, 122,
		0, 1471, 1517, 1, 0, 0, 0, 1472, 1473, 5, 68, 0, 0, 1473, 1475, 3, 254,
		127, 0, 1474, 1476, 3, 12, 6, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1,
		0, 0, 0, 1476, 1517, 1, 0, 0, 0, 1477, 1478, 5, 85, 0, 0, 1478, 1517, 3,
		254, 127, 38, 1479, 1480, 5, 73, 0, 0, 1480, 1517, 3, 254, 127, 37, 1481,
		1482, 5, 65, 0, 0, 1482, 1517, 3, 254, 127, 36, 1483, 1484, 5, 18, 0, 0,
		1484, 1517, 3, 254, 127, 35, 1485, 1486, 5, 19, 0, 0, 1486, 1517, 3, 254,
		127, 34, 1487, 1488, 5, 20, 0, 0, 1488, 1517, 3, 254, 127, 33, 1489, 1490,
		5, 21, 0, 0, 1490, 1517, 3, 254, 127, 32, 1491, 1492, 5, 22, 0, 0, 1492,
		1517, 3, 254, 127, 31, 1493, 1494, 5, 23, 0, 0, 1494, 1517, 3, 254, 127,
		30, 1495, 1517, 3, 214, 107, 0, 1496, 1517, 3, 210, 105, 0, 1497, 1517,
		3, 208, 104, 0, 1498, 1517, 3, 160, 80, 0, 1499, 1517, 5, 80, 0, 0, 1500,
		1502, 3, 274, 137, 0, 1501, 1503, 3, 254, 127, 0, 1502, 1501, 1, 0, 0,
		0, 1502, 1503, 1, 0, 0, 0, 1503, 1517, 1, 0, 0, 0, 1504, 1517, 5, 95, 0,
		0, 1505, 1517, 3, 266, 133, 0, 1506, 1517, 3, 228, 114, 0, 1507, 1517,
		3, 234, 117, 0, 1508, 1509, 5, 6, 0, 0, 1509, 1510, 3, 250, 125, 0, 1510,
		1511, 5, 7, 0, 0, 1511, 1517, 1, 0, 0, 0, 1512, 1514, 3, 12, 6, 0, 1513,
		1515, 3, 250, 125, 0, 1514, 1513, 1, 0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515,
		1517, 1, 0, 0, 0, 1516, 1462, 1, 0, 0, 0, 1516, 1464, 1, 0, 0, 0, 1516,
		1465, 1, 0, 0, 0, 1516, 1472, 1, 0, 0, 0, 1516, 1477, 1, 0, 0, 0, 1516,
		1479, 1, 0, 0, 0, 1516, 1481, 1, 0, 0, 0, 1516, 1483, 1, 0, 0, 0, 1516,
		1485, 1, 0, 0, 0, 1516, 1487, 1, 0, 0, 0, 1516, 1489, 1, 0, 0, 0, 1516,
		1491, 1, 0, 0, 0, 1516, 1493, 1, 0, 0, 0, 1516, 1495, 1, 0, 0, 0, 1516,
		1496, 1, 0, 0, 0, 1516, 1497, 1, 0, 0, 0, 1516, 1498, 1, 0, 0, 0, 1516,
		1499, 1, 0, 0, 0, 1516, 1500, 1, 0, 0, 0, 1516, 1504, 1, 0, 0, 0, 1516,
		1505, 1, 0, 0, 0, 1516, 1506, 1, 0, 0, 0, 1516, 1507, 1, 0, 0, 0, 1516,
		1508, 1, 0, 0, 0, 1516, 1512, 1, 0, 0, 0, 1517, 1596, 1, 0, 0, 0, 1518,
		1519, 10, 29, 0, 0, 1519, 1520, 7, 6, 0, 0, 1520, 1595, 3, 254, 127, 30,
		1521, 1522, 10, 28, 0, 0, 1522, 1523, 7, 7, 0, 0, 1523, 1595, 3, 254, 127,
		29, 1524, 1525, 10, 27, 0, 0, 1525, 1526, 7, 8, 0, 0, 1526, 1595, 3, 254,
		127, 28, 1527, 1528, 10, 26, 0, 0, 1528, 1529, 7, 9, 0, 0, 1529, 1595,
		3, 254, 127, 27, 1530, 1531, 10, 25, 0, 0, 1531, 1532, 5, 64, 0, 0, 1532,
		1595, 3, 254, 127, 26, 1533, 1534, 10, 24, 0, 0, 1534, 1535, 5, 86, 0,
		0, 1535, 1595, 3, 254, 127, 25, 1536, 1537, 10, 23, 0, 0, 1537, 1538, 7,
		10, 0, 0, 1538, 1595, 3, 254, 127, 24, 1539, 1540, 10, 22, 0, 0, 1540,
		1541, 5, 38, 0, 0, 1541, 1595, 3, 254, 127, 23, 1542, 1543, 10, 21, 0,
		0, 1543, 1544, 5, 39, 0, 0, 1544, 1595, 3, 254, 127, 22, 1545, 1546, 10,
		20, 0, 0, 1546, 1547, 5, 40, 0, 0, 1547, 1595, 3, 254, 127, 21, 1548, 1549,
		10, 19, 0, 0, 1549, 1550, 5, 41, 0, 0, 1550, 1595, 3, 254, 127, 20, 1551,
		1552, 10, 18, 0, 0, 1552, 1553, 5, 42, 0, 0, 1553, 1595, 3, 254, 127, 19,
		1554, 1555, 10, 17, 0, 0, 1555, 1556, 5, 14, 0, 0, 1556, 1557, 3, 254,
		127, 0, 1557, 1558, 5, 15, 0, 0, 1558, 1559, 3, 254, 127, 18, 1559, 1595,
		1, 0, 0, 0, 1560, 1561, 10, 16, 0, 0, 1561, 1562, 5, 13, 0, 0, 1562, 1595,
		3, 254, 127, 17, 1563, 1564, 10, 15, 0, 0, 1564, 1565, 3, 264, 132, 0,
		1565, 1566, 3, 254, 127, 16, 1566, 1595, 1, 0, 0, 0, 1567, 1568, 10, 45,
		0, 0, 1568, 1569, 5, 4, 0, 0, 1569, 1570, 3, 250, 125, 0, 1570, 1571, 5,
		5, 0, 0, 1571, 1595, 1, 0, 0, 0, 1572, 1574, 10, 44, 0, 0, 1573, 1575,
		5, 23, 0, 0, 1574, 1573, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1576,
		1, 0, 0, 0, 1576, 1577, 5, 17, 0, 0, 1577, 1579, 3, 274, 137, 0, 1578,
		1580, 3, 28, 14, 0, 1579, 1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580,
		1595, 1, 0, 0, 0, 1581, 1582, 10, 41, 0, 0, 1582, 1595, 3, 244, 122, 0,
		1583, 1584, 10, 40, 0, 0, 1584, 1585, 4, 127, 33, 0, 1585, 1595, 5, 18,
		0, 0, 1586, 1587, 10, 39, 0, 0, 1587, 1588, 4, 127, 35, 0, 1588, 1595,
		5, 19, 0, 0, 1589, 1590, 10, 14, 0, 0, 1590, 1595, 3, 268, 134, 0, 1591,
		1592, 10, 1, 0, 0, 1592, 1593, 5, 88, 0, 0, 1593, 1595, 3, 256, 128, 0,
		1594, 1518, 1, 0, 0, 0, 1594, 1521, 1, 0, 0, 0, 1594, 1524, 1, 0, 0, 0,
		1594, 1527, 1, 0, 0, 0, 1594, 1530, 1, 0, 0, 0, 1594, 1533, 1, 0, 0, 0,
		1594, 1536, 1, 0, 0, 0, 1594, 1539, 1, 0, 0, 0, 1594, 1542, 1, 0, 0, 0,
		1594, 1545, 1, 0, 0, 0, 1594, 1548, 1, 0, 0, 0, 1594, 1551, 1, 0, 0, 0,
		1594, 1554, 1, 0, 0, 0, 1594, 1560, 1, 0, 0, 0, 1594, 1563, 1, 0, 0, 0,
		1594, 1567, 1, 0, 0, 0, 1594, 1572, 1, 0, 0, 0, 1594, 1581, 1, 0, 0, 0,
		1594, 1583, 1, 0, 0, 0, 1594, 1586, 1, 0, 0, 0, 1594, 1589, 1, 0, 0, 0,
		1594, 1591, 1, 0, 0, 0, 1595, 1598, 1, 0, 0, 0, 1596, 1594, 1, 0, 0, 0,
		1596, 1597, 1, 0, 0, 0, 1597, 255, 1, 0, 0, 0, 1598, 1596, 1, 0, 0, 0,
		1599, 1602, 3, 24, 12, 0, 1600, 1601, 5, 4, 0, 0, 1601, 1603, 5, 5, 0,
		0, 1602, 1600, 1, 0, 0, 0, 1602, 1603, 1, 0, 0, 0, 1603, 1606, 1, 0, 0,
		0, 1604, 1606, 3, 254, 127, 0, 1605, 1599, 1, 0, 0, 0, 1605, 1604, 1, 0,
		0, 0, 1606, 257, 1, 0, 0, 0, 1607, 1609, 5, 91, 0, 0, 1608, 1607, 1, 0,
		0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 1612, 3, 260,
		130, 0, 1611, 1613, 3, 60, 30, 0, 1612, 1611, 1, 0, 0, 0, 1612, 1613, 1,
		0, 0, 0, 1613, 1614, 1, 0, 0, 0, 1614, 1615, 5, 54, 0, 0, 1615, 1616, 3,
		262, 131, 0, 1616, 259, 1, 0, 0, 0, 1617, 1624, 5, 124, 0, 0, 1618, 1620,
		5, 6, 0, 0, 1619, 1621, 3, 218, 109, 0, 1620, 1619, 1, 0, 0, 0, 1620, 1621,
		1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 1624, 5, 7, 0, 0, 1623, 1617,
		1, 0, 0, 0, 1623, 1618, 1, 0, 0, 0, 1624, 261, 1, 0, 0, 0, 1625, 1631,
		3, 254, 127, 0, 1626, 1627, 5, 8, 0, 0, 1627, 1628, 3, 224, 112, 0, 1628,
		1629, 5, 10, 0, 0, 1629, 1631, 1, 0, 0, 0, 1630, 1625, 1, 0, 0, 0, 1630,
		1626, 1, 0, 0, 0, 1631, 263, 1, 0, 0, 0, 1632, 1633, 7, 11, 0, 0, 1633,
		265, 1, 0, 0, 0, 1634, 1641, 5, 55, 0, 0, 1635, 1641, 5, 56, 0, 0, 1636,
		1641, 5, 125, 0, 0, 1637, 1641, 3, 268, 134, 0, 1638, 1641, 5, 3, 0, 0,
		1639, 1641, 3, 272, 136, 0, 1640, 1634, 1, 0, 0, 0, 1640, 1635, 1, 0, 0,
		0, 1640, 1636, 1, 0, 0, 0, 1640, 1637, 1, 0, 0, 0, 1640, 1638, 1, 0, 0,
		0, 1640, 1639, 1, 0, 0, 0, 1641, 267, 1, 0, 0, 0, 1642, 1646, 5, 126, 0,
		0, 1643, 1645, 3, 270, 135, 0, 1644, 1643, 1, 0, 0, 0, 1645, 1648, 1, 0,
		0, 0, 1646, 1644, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1649, 1, 0,
		0, 0, 1648, 1646, 1, 0, 0, 0, 1649, 1650, 5, 126, 0, 0, 1650, 269, 1, 0,
		0, 0, 1651, 1658, 5, 134, 0, 0, 1652, 1653, 5, 133, 0, 0, 1653, 1654, 3,
		254, 127, 0, 1654, 1655, 5, 9, 0, 0, 1655, 1658, 1, 0, 0, 0, 1656, 1658,
		5, 132, 0, 0, 1657, 1651, 1, 0, 0, 0, 1657, 1652, 1, 0, 0, 0, 1657, 1656,
		1, 0, 0, 0, 1658, 271, 1, 0, 0, 0, 1659, 1660, 7, 12, 0, 0, 1660, 273,
		1, 0, 0, 0, 1661, 1664, 5, 124, 0, 0, 1662, 1664, 3, 278, 139, 0, 1663,
		1661, 1, 0, 0, 0, 1663, 1662, 1, 0, 0, 0, 1664, 275, 1, 0, 0, 0, 1665,
		1666, 7, 13, 0, 0, 1666, 277, 1, 0, 0, 0, 1667, 1671, 3, 280, 140, 0, 1668,
		1671, 5, 55, 0, 0, 1669, 1671, 5, 56, 0, 0, 1670, 1667, 1, 0, 0, 0, 1670,
		1668, 1, 0, 0, 0, 1670, 1669, 1, 0, 0, 0, 1671, 279, 1, 0, 0, 0, 1672,
		1673, 7, 14, 0, 0, 1673, 281, 1, 0, 0, 0, 1674, 1675, 5, 114, 0, 0, 1675,
		1676, 3, 242, 121, 0, 1676, 283, 1, 0, 0, 0, 1677, 1678, 5, 115, 0, 0,
		1678, 1679, 3, 242, 121, 0, 1679, 285, 1, 0, 0, 0, 1680, 1685, 5, 11, 0,
		0, 1681, 1685, 5, 0, 0, 1, 1682, 1685, 4, 143, 38, 0, 1683, 1685, 4, 143,
		39, 0, 1684, 1680, 1, 0, 0, 0, 1684, 1681, 1, 0, 0, 0, 1684, 1682, 1, 0,
		0, 0, 1684, 1683, 1, 0, 0, 0, 1685, 287, 1, 0, 0, 0, 213, 293, 297, 306,
		311, 314, 321, 330, 340, 351, 353, 374, 382, 389, 393, 408, 412, 416, 422,
		429, 439, 441, 457, 461, 465, 473, 477, 492, 496, 499, 503, 506, 510, 516,
		520, 524, 532, 537, 539, 546, 551, 554, 557, 562, 565, 568, 573, 576, 579,
		583, 589, 593, 597, 601, 612, 619, 626, 631, 639, 642, 645, 650, 653, 657,
		667, 671, 677, 683, 690, 696, 702, 710, 715, 726, 731, 739, 746, 753, 758,
		791, 795, 802, 808, 815, 819, 823, 832, 840, 847, 851, 855, 859, 862, 865,
		868, 872, 876, 880, 882, 889, 895, 898, 901, 905, 908, 915, 924, 943, 947,
		951, 961, 965, 976, 989, 995, 1002, 1009, 1016, 1023, 1041, 1045, 1047,
		1054, 1060, 1065, 1080, 1083, 1105, 1108, 1112, 1114, 1117, 1122, 1128,
		1131, 1137, 1150, 1155, 1160, 1163, 1166, 1178, 1183, 1186, 1189, 1192,
		1195, 1198, 1204, 1209, 1219, 1223, 1236, 1240, 1253, 1257, 1266, 1278,
		1283, 1290, 1292, 1295, 1298, 1302, 1305, 1309, 1314, 1317, 1322, 1326,
		1334, 1339, 1343, 1347, 1350, 1358, 1362, 1364, 1383, 1389, 1399, 1402,
		1412, 1417, 1419, 1428, 1432, 1436, 1443, 1448, 1452, 1456, 1468, 1475,
		1502, 1514, 1516, 1574, 1579, 1594, 1596, 1602, 1605, 1608, 1612, 1620,
		1623, 1630, 1640, 1646, 1657, 1663, 1670, 1684,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// TypeScriptParserInit initializes any static state used to implement TypeScriptParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewTypeScriptParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func TypeScriptParserInit() {
	staticData := &TypeScriptParserParserStaticData
	staticData.once.Do(typescriptparserParserInit)
}

// NewTypeScriptParser produces a new parser instance for the optional input antlr.TokenStream.
func NewTypeScriptParser(input antlr.TokenStream) *TypeScriptParser {
	TypeScriptParserInit()
	this := new(TypeScriptParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &TypeScriptParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "TypeScriptParser.g4"

	return this
}

// TypeScriptParser tokens.
const (
	TypeScriptParserEOF                           = antlr.TokenEOF
	TypeScriptParserMultiLineComment              = 1
	TypeScriptParserSingleLineComment             = 2
	TypeScriptParserRegularExpressionLiteral      = 3
	TypeScriptParserOpenBracket                   = 4
	TypeScriptParserCloseBracket                  = 5
	TypeScriptParserOpenParen                     = 6
	TypeScriptParserCloseParen                    = 7
	TypeScriptParserOpenBrace                     = 8
	TypeScriptParserTemplateCloseBrace            = 9
	TypeScriptParserCloseBrace                    = 10
	TypeScriptParserSemiColon                     = 11
	TypeScriptParserComma                         = 12
	TypeScriptParserAssign                        = 13
	TypeScriptParserQuestionMark                  = 14
	TypeScriptParserColon                         = 15
	TypeScriptParserEllipsis                      = 16
	TypeScriptParserDot                           = 17
	TypeScriptParserPlusPlus                      = 18
	TypeScriptParserMinusMinus                    = 19
	TypeScriptParserPlus                          = 20
	TypeScriptParserMinus                         = 21
	TypeScriptParserBitNot                        = 22
	TypeScriptParserNot                           = 23
	TypeScriptParserMultiply                      = 24
	TypeScriptParserDivide                        = 25
	TypeScriptParserModulus                       = 26
	TypeScriptParserRightShiftArithmetic          = 27
	TypeScriptParserLeftShiftArithmetic           = 28
	TypeScriptParserRightShiftLogical             = 29
	TypeScriptParserLessThan                      = 30
	TypeScriptParserMoreThan                      = 31
	TypeScriptParserLessThanEquals                = 32
	TypeScriptParserGreaterThanEquals             = 33
	TypeScriptParserEquals_                       = 34
	TypeScriptParserNotEquals                     = 35
	TypeScriptParserIdentityEquals                = 36
	TypeScriptParserIdentityNotEquals             = 37
	TypeScriptParserBitAnd                        = 38
	TypeScriptParserBitXOr                        = 39
	TypeScriptParserBitOr                         = 40
	TypeScriptParserAnd                           = 41
	TypeScriptParserOr                            = 42
	TypeScriptParserMultiplyAssign                = 43
	TypeScriptParserDivideAssign                  = 44
	TypeScriptParserModulusAssign                 = 45
	TypeScriptParserPlusAssign                    = 46
	TypeScriptParserMinusAssign                   = 47
	TypeScriptParserLeftShiftArithmeticAssign     = 48
	TypeScriptParserRightShiftArithmeticAssign    = 49
	TypeScriptParserRightShiftLogicalAssign       = 50
	TypeScriptParserBitAndAssign                  = 51
	TypeScriptParserBitXorAssign                  = 52
	TypeScriptParserBitOrAssign                   = 53
	TypeScriptParserARROW                         = 54
	TypeScriptParserNullLiteral                   = 55
	TypeScriptParserBooleanLiteral                = 56
	TypeScriptParserDecimalLiteral                = 57
	TypeScriptParserHexIntegerLiteral             = 58
	TypeScriptParserOctalIntegerLiteral           = 59
	TypeScriptParserOctalIntegerLiteral2          = 60
	TypeScriptParserBinaryIntegerLiteral          = 61
	TypeScriptParserBreak                         = 62
	TypeScriptParserDo                            = 63
	TypeScriptParserInstanceof                    = 64
	TypeScriptParserTypeof                        = 65
	TypeScriptParserCase                          = 66
	TypeScriptParserElse                          = 67
	TypeScriptParserNew                           = 68
	TypeScriptParserVar                           = 69
	TypeScriptParserCatch                         = 70
	TypeScriptParserFinally                       = 71
	TypeScriptParserReturn                        = 72
	TypeScriptParserVoid                          = 73
	TypeScriptParserContinue                      = 74
	TypeScriptParserFor                           = 75
	TypeScriptParserSwitch                        = 76
	TypeScriptParserWhile                         = 77
	TypeScriptParserDebugger                      = 78
	TypeScriptParserFunction_                     = 79
	TypeScriptParserThis                          = 80
	TypeScriptParserWith                          = 81
	TypeScriptParserDefault                       = 82
	TypeScriptParserIf                            = 83
	TypeScriptParserThrow                         = 84
	TypeScriptParserDelete                        = 85
	TypeScriptParserIn                            = 86
	TypeScriptParserTry                           = 87
	TypeScriptParserAs                            = 88
	TypeScriptParserFrom                          = 89
	TypeScriptParserReadOnly                      = 90
	TypeScriptParserAsync                         = 91
	TypeScriptParserClass                         = 92
	TypeScriptParserEnum                          = 93
	TypeScriptParserExtends                       = 94
	TypeScriptParserSuper                         = 95
	TypeScriptParserConst                         = 96
	TypeScriptParserExport                        = 97
	TypeScriptParserImport                        = 98
	TypeScriptParserImplements                    = 99
	TypeScriptParserLet                           = 100
	TypeScriptParserPrivate                       = 101
	TypeScriptParserPublic                        = 102
	TypeScriptParserInterface                     = 103
	TypeScriptParserPackage                       = 104
	TypeScriptParserProtected                     = 105
	TypeScriptParserStatic                        = 106
	TypeScriptParserYield                         = 107
	TypeScriptParserAny                           = 108
	TypeScriptParserNumber                        = 109
	TypeScriptParserBoolean                       = 110
	TypeScriptParserString_                       = 111
	TypeScriptParserSymbol                        = 112
	TypeScriptParserTypeAlias                     = 113
	TypeScriptParserGet                           = 114
	TypeScriptParserSet                           = 115
	TypeScriptParserConstructor                   = 116
	TypeScriptParserNamespace                     = 117
	TypeScriptParserRequire                       = 118
	TypeScriptParserModule                        = 119
	TypeScriptParserDeclare                       = 120
	TypeScriptParserAbstract                      = 121
	TypeScriptParserIs                            = 122
	TypeScriptParserAt                            = 123
	TypeScriptParserIdentifier                    = 124
	TypeScriptParserStringLiteral                 = 125
	TypeScriptParserBackTick                      = 126
	TypeScriptParserWhiteSpaces                   = 127
	TypeScriptParserLineTerminator                = 128
	TypeScriptParserHtmlComment                   = 129
	TypeScriptParserCDataComment                  = 130
	TypeScriptParserUnexpectedCharacter           = 131
	TypeScriptParserTemplateStringEscapeAtom      = 132
	TypeScriptParserTemplateStringStartExpression = 133
	TypeScriptParserTemplateStringAtom            = 134
)

// TypeScriptParser rules.
const (
	TypeScriptParserRULE_initializer                      = 0
	TypeScriptParserRULE_bindingPattern                   = 1
	TypeScriptParserRULE_typeParameters                   = 2
	TypeScriptParserRULE_typeParameterList                = 3
	TypeScriptParserRULE_typeParameter                    = 4
	TypeScriptParserRULE_constraint                       = 5
	TypeScriptParserRULE_typeArguments                    = 6
	TypeScriptParserRULE_typeArgumentList                 = 7
	TypeScriptParserRULE_typeArgument                     = 8
	TypeScriptParserRULE_type_                            = 9
	TypeScriptParserRULE_unionOrIntersectionOrPrimaryType = 10
	TypeScriptParserRULE_primaryType                      = 11
	TypeScriptParserRULE_predefinedType                   = 12
	TypeScriptParserRULE_typeReference                    = 13
	TypeScriptParserRULE_nestedTypeGeneric                = 14
	TypeScriptParserRULE_typeGeneric                      = 15
	TypeScriptParserRULE_typeIncludeGeneric               = 16
	TypeScriptParserRULE_typeName                         = 17
	TypeScriptParserRULE_objectType                       = 18
	TypeScriptParserRULE_typeBody                         = 19
	TypeScriptParserRULE_typeMemberList                   = 20
	TypeScriptParserRULE_typeMember                       = 21
	TypeScriptParserRULE_arrayType                        = 22
	TypeScriptParserRULE_tupleType                        = 23
	TypeScriptParserRULE_tupleElementTypes                = 24
	TypeScriptParserRULE_functionType                     = 25
	TypeScriptParserRULE_constructorType                  = 26
	TypeScriptParserRULE_typeQuery                        = 27
	TypeScriptParserRULE_typeQueryExpression              = 28
	TypeScriptParserRULE_propertySignatur                 = 29
	TypeScriptParserRULE_typeAnnotation                   = 30
	TypeScriptParserRULE_callSignature                    = 31
	TypeScriptParserRULE_parameterList                    = 32
	TypeScriptParserRULE_requiredParameterList            = 33
	TypeScriptParserRULE_parameter                        = 34
	TypeScriptParserRULE_optionalParameter                = 35
	TypeScriptParserRULE_restParameter                    = 36
	TypeScriptParserRULE_requiredParameter                = 37
	TypeScriptParserRULE_accessibilityModifier            = 38
	TypeScriptParserRULE_identifierOrPattern              = 39
	TypeScriptParserRULE_constructSignature               = 40
	TypeScriptParserRULE_indexSignature                   = 41
	TypeScriptParserRULE_methodSignature                  = 42
	TypeScriptParserRULE_typeAliasDeclaration             = 43
	TypeScriptParserRULE_constructorDeclaration           = 44
	TypeScriptParserRULE_interfaceDeclaration             = 45
	TypeScriptParserRULE_interfaceExtendsClause           = 46
	TypeScriptParserRULE_classOrInterfaceTypeList         = 47
	TypeScriptParserRULE_enumDeclaration                  = 48
	TypeScriptParserRULE_enumBody                         = 49
	TypeScriptParserRULE_enumMemberList                   = 50
	TypeScriptParserRULE_enumMember                       = 51
	TypeScriptParserRULE_namespaceDeclaration             = 52
	TypeScriptParserRULE_namespaceName                    = 53
	TypeScriptParserRULE_importAliasDeclaration           = 54
	TypeScriptParserRULE_decoratorList                    = 55
	TypeScriptParserRULE_decorator                        = 56
	TypeScriptParserRULE_decoratorMemberExpression        = 57
	TypeScriptParserRULE_decoratorCallExpression          = 58
	TypeScriptParserRULE_program                          = 59
	TypeScriptParserRULE_sourceElement                    = 60
	TypeScriptParserRULE_statement                        = 61
	TypeScriptParserRULE_block                            = 62
	TypeScriptParserRULE_statementList                    = 63
	TypeScriptParserRULE_abstractDeclaration              = 64
	TypeScriptParserRULE_importStatement                  = 65
	TypeScriptParserRULE_fromBlock                        = 66
	TypeScriptParserRULE_multipleImportStatement          = 67
	TypeScriptParserRULE_exportStatement                  = 68
	TypeScriptParserRULE_variableStatement                = 69
	TypeScriptParserRULE_variableDeclarationList          = 70
	TypeScriptParserRULE_variableDeclaration              = 71
	TypeScriptParserRULE_emptyStatement_                  = 72
	TypeScriptParserRULE_expressionStatement              = 73
	TypeScriptParserRULE_ifStatement                      = 74
	TypeScriptParserRULE_iterationStatement               = 75
	TypeScriptParserRULE_varModifier                      = 76
	TypeScriptParserRULE_continueStatement                = 77
	TypeScriptParserRULE_breakStatement                   = 78
	TypeScriptParserRULE_returnStatement                  = 79
	TypeScriptParserRULE_yieldStatement                   = 80
	TypeScriptParserRULE_withStatement                    = 81
	TypeScriptParserRULE_switchStatement                  = 82
	TypeScriptParserRULE_caseBlock                        = 83
	TypeScriptParserRULE_caseClauses                      = 84
	TypeScriptParserRULE_caseClause                       = 85
	TypeScriptParserRULE_defaultClause                    = 86
	TypeScriptParserRULE_labelledStatement                = 87
	TypeScriptParserRULE_throwStatement                   = 88
	TypeScriptParserRULE_tryStatement                     = 89
	TypeScriptParserRULE_catchProduction                  = 90
	TypeScriptParserRULE_finallyProduction                = 91
	TypeScriptParserRULE_debuggerStatement                = 92
	TypeScriptParserRULE_functionDeclaration              = 93
	TypeScriptParserRULE_classDeclaration                 = 94
	TypeScriptParserRULE_classHeritage                    = 95
	TypeScriptParserRULE_classTail                        = 96
	TypeScriptParserRULE_classExtendsClause               = 97
	TypeScriptParserRULE_implementsClause                 = 98
	TypeScriptParserRULE_classElement                     = 99
	TypeScriptParserRULE_propertyMemberDeclaration        = 100
	TypeScriptParserRULE_propertyMemberBase               = 101
	TypeScriptParserRULE_indexMemberDeclaration           = 102
	TypeScriptParserRULE_generatorMethod                  = 103
	TypeScriptParserRULE_generatorFunctionDeclaration     = 104
	TypeScriptParserRULE_generatorBlock                   = 105
	TypeScriptParserRULE_generatorDefinition              = 106
	TypeScriptParserRULE_iteratorBlock                    = 107
	TypeScriptParserRULE_iteratorDefinition               = 108
	TypeScriptParserRULE_formalParameterList              = 109
	TypeScriptParserRULE_formalParameterArg               = 110
	TypeScriptParserRULE_lastFormalParameterArg           = 111
	TypeScriptParserRULE_functionBody                     = 112
	TypeScriptParserRULE_sourceElements                   = 113
	TypeScriptParserRULE_arrayLiteral                     = 114
	TypeScriptParserRULE_elementList                      = 115
	TypeScriptParserRULE_arrayElement                     = 116
	TypeScriptParserRULE_objectLiteral                    = 117
	TypeScriptParserRULE_propertyAssignment               = 118
	TypeScriptParserRULE_getAccessor                      = 119
	TypeScriptParserRULE_setAccessor                      = 120
	TypeScriptParserRULE_propertyName                     = 121
	TypeScriptParserRULE_arguments                        = 122
	TypeScriptParserRULE_argumentList                     = 123
	TypeScriptParserRULE_argument                         = 124
	TypeScriptParserRULE_expressionSequence               = 125
	TypeScriptParserRULE_functionExpressionDeclaration    = 126
	TypeScriptParserRULE_singleExpression                 = 127
	TypeScriptParserRULE_asExpression                     = 128
	TypeScriptParserRULE_arrowFunctionDeclaration         = 129
	TypeScriptParserRULE_arrowFunctionParameters          = 130
	TypeScriptParserRULE_arrowFunctionBody                = 131
	TypeScriptParserRULE_assignmentOperator               = 132
	TypeScriptParserRULE_literal                          = 133
	TypeScriptParserRULE_templateStringLiteral            = 134
	TypeScriptParserRULE_templateStringAtom               = 135
	TypeScriptParserRULE_numericLiteral                   = 136
	TypeScriptParserRULE_identifierName                   = 137
	TypeScriptParserRULE_identifierOrKeyWord              = 138
	TypeScriptParserRULE_reservedWord                     = 139
	TypeScriptParserRULE_keyword                          = 140
	TypeScriptParserRULE_getter                           = 141
	TypeScriptParserRULE_setter                           = 142
	TypeScriptParserRULE_eos                              = 143
)

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_initializer
	return p
}

func InitEmptyInitializerContext(p *InitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_initializer
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *InitializerContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, TypeScriptParserRULE_initializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.Match(TypeScriptParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingPatternContext is an interface to support dynamic dispatch.
type IBindingPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext

	// IsBindingPatternContext differentiates from other interfaces.
	IsBindingPatternContext()
}

type BindingPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingPatternContext() *BindingPatternContext {
	var p = new(BindingPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_bindingPattern
	return p
}

func InitEmptyBindingPatternContext(p *BindingPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_bindingPattern
}

func (*BindingPatternContext) IsBindingPatternContext() {}

func NewBindingPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingPatternContext {
	var p = new(BindingPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_bindingPattern

	return p
}

func (s *BindingPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingPatternContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *BindingPatternContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *BindingPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBindingPattern(s)
	}
}

func (s *BindingPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBindingPattern(s)
	}
}

func (s *BindingPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBindingPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) BindingPattern() (localctx IBindingPatternContext) {
	localctx = NewBindingPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, TypeScriptParserRULE_bindingPattern)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserOpenBracket:
		{
			p.SetState(291)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		{
			p.SetState(292)
			p.ObjectLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LessThan() antlr.TerminalNode
	MoreThan() antlr.TerminalNode
	TypeParameterList() ITypeParameterListContext

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeParametersContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeParametersContext) TypeParameterList() ITypeParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, TypeScriptParserRULE_typeParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(TypeScriptParserLessThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan || _la == TypeScriptParserIdentifier {
		{
			p.SetState(296)
			p.TypeParameterList()
		}

	}
	{
		p.SetState(299)
		p.Match(TypeScriptParserMoreThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameterList
	return p
}

func InitEmptyTypeParameterListContext(p *TypeParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameterList
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeParameterList() (localctx ITypeParameterListContext) {
	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, TypeScriptParserRULE_typeParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(301)
		p.TypeParameter()
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(302)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)
			p.TypeParameter()
		}

		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Constraint() IConstraintContext
	TypeParameters() ITypeParametersContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeParameterContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *TypeParameterContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, TypeScriptParserRULE_typeParameter)
	var _la int

	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(309)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserExtends {
			{
				p.SetState(310)
				p.Constraint()
			}

		}

	case TypeScriptParserLessThan:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(313)
			p.TypeParameters()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Extends() antlr.TerminalNode
	Type_() IType_Context

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *ConstraintContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (s *ConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, TypeScriptParserRULE_constraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Match(TypeScriptParserExtends)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(317)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LessThan() antlr.TerminalNode
	MoreThan() antlr.TerminalNode
	TypeArgumentList() ITypeArgumentListContext

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeArgumentsContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeArgumentsContext) TypeArgumentList() ITypeArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, TypeScriptParserRULE_typeArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		p.Match(TypeScriptParserLessThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1073742160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&1729654935793991945) != 0) {
		{
			p.SetState(320)
			p.TypeArgumentList()
		}

	}
	{
		p.SetState(323)
		p.Match(TypeScriptParserMoreThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentListContext is an interface to support dynamic dispatch.
type ITypeArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeArgument() []ITypeArgumentContext
	TypeArgument(i int) ITypeArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTypeArgumentListContext differentiates from other interfaces.
	IsTypeArgumentListContext()
}

type TypeArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentListContext() *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgumentList
	return p
}

func InitEmptyTypeArgumentListContext(p *TypeArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgumentList
}

func (*TypeArgumentListContext) IsTypeArgumentListContext() {}

func NewTypeArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArgumentList

	return p
}

func (s *TypeArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentListContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentListContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArgumentList(s)
	}
}

func (s *TypeArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArgumentList(s)
	}
}

func (s *TypeArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeArgumentList() (localctx ITypeArgumentListContext) {
	localctx = NewTypeArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, TypeScriptParserRULE_typeArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.TypeArgument()
	}
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(326)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(327)
			p.TypeArgument()
		}

		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgument
	return p
}

func InitEmptyTypeArgumentContext(p *TypeArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgument
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (s *TypeArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, TypeScriptParserRULE_typeArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnionOrIntersectionOrPrimaryType() IUnionOrIntersectionOrPrimaryTypeContext
	FunctionType() IFunctionTypeContext
	ConstructorType() IConstructorTypeContext
	TypeGeneric() ITypeGenericContext
	StringLiteral() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) UnionOrIntersectionOrPrimaryType() IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *Type_Context) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *Type_Context) ConstructorType() IConstructorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorTypeContext)
}

func (s *Type_Context) TypeGeneric() ITypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeGenericContext)
}

func (s *Type_Context) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, TypeScriptParserRULE_type_)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(335)
			p.unionOrIntersectionOrPrimaryType(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(336)
			p.FunctionType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(337)
			p.ConstructorType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(338)
			p.TypeGeneric()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(339)
			p.Match(TypeScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionOrIntersectionOrPrimaryTypeContext is an interface to support dynamic dispatch.
type IUnionOrIntersectionOrPrimaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnionOrIntersectionOrPrimaryTypeContext differentiates from other interfaces.
	IsUnionOrIntersectionOrPrimaryTypeContext()
}

type UnionOrIntersectionOrPrimaryTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionOrIntersectionOrPrimaryTypeContext() *UnionOrIntersectionOrPrimaryTypeContext {
	var p = new(UnionOrIntersectionOrPrimaryTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_unionOrIntersectionOrPrimaryType
	return p
}

func InitEmptyUnionOrIntersectionOrPrimaryTypeContext(p *UnionOrIntersectionOrPrimaryTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_unionOrIntersectionOrPrimaryType
}

func (*UnionOrIntersectionOrPrimaryTypeContext) IsUnionOrIntersectionOrPrimaryTypeContext() {}

func NewUnionOrIntersectionOrPrimaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionOrIntersectionOrPrimaryTypeContext {
	var p = new(UnionOrIntersectionOrPrimaryTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_unionOrIntersectionOrPrimaryType

	return p
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionOrIntersectionOrPrimaryTypeContext) CopyAll(ctx *UnionOrIntersectionOrPrimaryTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IntersectionContext struct {
	UnionOrIntersectionOrPrimaryTypeContext
}

func NewIntersectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntersectionContext {
	var p = new(IntersectionContext)

	InitEmptyUnionOrIntersectionOrPrimaryTypeContext(&p.UnionOrIntersectionOrPrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *IntersectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionContext) AllUnionOrIntersectionOrPrimaryType() []IUnionOrIntersectionOrPrimaryTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			len++
		}
	}

	tst := make([]IUnionOrIntersectionOrPrimaryTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			tst[i] = t.(IUnionOrIntersectionOrPrimaryTypeContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionContext) UnionOrIntersectionOrPrimaryType(i int) IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *IntersectionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAnd, 0)
}

func (s *IntersectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIntersection(s)
	}
}

func (s *IntersectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIntersection(s)
	}
}

func (s *IntersectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIntersection(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryContext struct {
	UnionOrIntersectionOrPrimaryTypeContext
}

func NewPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryContext {
	var p = new(PrimaryContext)

	InitEmptyUnionOrIntersectionOrPrimaryTypeContext(&p.UnionOrIntersectionOrPrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (s *PrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnionContext struct {
	UnionOrIntersectionOrPrimaryTypeContext
}

func NewUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionContext {
	var p = new(UnionContext)

	InitEmptyUnionOrIntersectionOrPrimaryTypeContext(&p.UnionOrIntersectionOrPrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) AllUnionOrIntersectionOrPrimaryType() []IUnionOrIntersectionOrPrimaryTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			len++
		}
	}

	tst := make([]IUnionOrIntersectionOrPrimaryTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			tst[i] = t.(IUnionOrIntersectionOrPrimaryTypeContext)
			i++
		}
	}

	return tst
}

func (s *UnionContext) UnionOrIntersectionOrPrimaryType(i int) IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *UnionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOr, 0)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (s *UnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) UnionOrIntersectionOrPrimaryType() (localctx IUnionOrIntersectionOrPrimaryTypeContext) {
	return p.unionOrIntersectionOrPrimaryType(0)
}

func (p *TypeScriptParser) unionOrIntersectionOrPrimaryType(_p int) (localctx IUnionOrIntersectionOrPrimaryTypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewUnionOrIntersectionOrPrimaryTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnionOrIntersectionOrPrimaryTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 20
	p.EnterRecursionRule(localctx, 20, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewPrimaryContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(343)
		p.primaryType(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
			case 1:
				localctx = NewUnionContext(p, NewUnionOrIntersectionOrPrimaryTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType)
				p.SetState(345)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(346)
					p.Match(TypeScriptParserBitOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(347)
					p.unionOrIntersectionOrPrimaryType(4)
				}

			case 2:
				localctx = NewIntersectionContext(p, NewUnionOrIntersectionOrPrimaryTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType)
				p.SetState(348)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(349)
					p.Match(TypeScriptParserBitAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(350)
					p.unionOrIntersectionOrPrimaryType(3)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryTypeContext is an interface to support dynamic dispatch.
type IPrimaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryTypeContext differentiates from other interfaces.
	IsPrimaryTypeContext()
}

type PrimaryTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryTypeContext() *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_primaryType
	return p
}

func InitEmptyPrimaryTypeContext(p *PrimaryTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_primaryType
}

func (*PrimaryTypeContext) IsPrimaryTypeContext() {}

func NewPrimaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_primaryType

	return p
}

func (s *PrimaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryTypeContext) CopyAll(ctx *PrimaryTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RedefinitionOfTypeContext struct {
	PrimaryTypeContext
}

func NewRedefinitionOfTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RedefinitionOfTypeContext {
	var p = new(RedefinitionOfTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *RedefinitionOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedefinitionOfTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *RedefinitionOfTypeContext) Is() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIs, 0)
}

func (s *RedefinitionOfTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *RedefinitionOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRedefinitionOfType(s)
	}
}

func (s *RedefinitionOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRedefinitionOfType(s)
	}
}

func (s *RedefinitionOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRedefinitionOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredefinedPrimTypeContext struct {
	PrimaryTypeContext
}

func NewPredefinedPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredefinedPrimTypeContext {
	var p = new(PredefinedPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *PredefinedPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedPrimTypeContext) PredefinedType() IPredefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedTypeContext)
}

func (s *PredefinedPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPredefinedPrimType(s)
	}
}

func (s *PredefinedPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPredefinedPrimType(s)
	}
}

func (s *PredefinedPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPredefinedPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayPrimTypeContext struct {
	PrimaryTypeContext
}

func NewArrayPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayPrimTypeContext {
	var p = new(ArrayPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ArrayPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayPrimTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ArrayPrimTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayPrimTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayPrimType(s)
	}
}

func (s *ArrayPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayPrimType(s)
	}
}

func (s *ArrayPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrayPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedPrimTypeContext struct {
	PrimaryTypeContext
}

func NewParenthesizedPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedPrimTypeContext {
	var p = new(ParenthesizedPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ParenthesizedPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedPrimTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ParenthesizedPrimTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParenthesizedPrimTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ParenthesizedPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParenthesizedPrimType(s)
	}
}

func (s *ParenthesizedPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParenthesizedPrimType(s)
	}
}

func (s *ParenthesizedPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitParenthesizedPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisPrimTypeContext struct {
	PrimaryTypeContext
}

func NewThisPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrimTypeContext {
	var p = new(ThisPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ThisPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrimTypeContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *ThisPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThisPrimType(s)
	}
}

func (s *ThisPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThisPrimType(s)
	}
}

func (s *ThisPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitThisPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type TuplePrimTypeContext struct {
	PrimaryTypeContext
}

func NewTuplePrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TuplePrimTypeContext {
	var p = new(TuplePrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *TuplePrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePrimTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *TuplePrimTypeContext) TupleElementTypes() ITupleElementTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementTypesContext)
}

func (s *TuplePrimTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *TuplePrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTuplePrimType(s)
	}
}

func (s *TuplePrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTuplePrimType(s)
	}
}

func (s *TuplePrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTuplePrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectPrimTypeContext struct {
	PrimaryTypeContext
}

func NewObjectPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectPrimTypeContext {
	var p = new(ObjectPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ObjectPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPrimTypeContext) ObjectType() IObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *ObjectPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectPrimType(s)
	}
}

func (s *ObjectPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectPrimType(s)
	}
}

func (s *ObjectPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitObjectPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReferencePrimTypeContext struct {
	PrimaryTypeContext
}

func NewReferencePrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferencePrimTypeContext {
	var p = new(ReferencePrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ReferencePrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencePrimTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ReferencePrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReferencePrimType(s)
	}
}

func (s *ReferencePrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReferencePrimType(s)
	}
}

func (s *ReferencePrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitReferencePrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimTypeContext struct {
	PrimaryTypeContext
}

func NewQueryPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimTypeContext {
	var p = new(QueryPrimTypeContext)

	InitEmptyPrimaryTypeContext(&p.PrimaryTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryTypeContext))

	return p
}

func (s *QueryPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimTypeContext) TypeQuery() ITypeQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQueryContext)
}

func (s *QueryPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterQueryPrimType(s)
	}
}

func (s *QueryPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitQueryPrimType(s)
	}
}

func (s *QueryPrimTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitQueryPrimType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PrimaryType() (localctx IPrimaryTypeContext) {
	return p.primaryType(0)
}

func (p *TypeScriptParser) primaryType(_p int) (localctx IPrimaryTypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 22
	p.EnterRecursionRule(localctx, 22, TypeScriptParserRULE_primaryType, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthesizedPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(357)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(358)
			p.Type_()
		}
		{
			p.SetState(359)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPredefinedPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(361)
			p.PredefinedType()
		}

	case 3:
		localctx = NewReferencePrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(362)
			p.TypeReference()
		}

	case 4:
		localctx = NewObjectPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(363)
			p.ObjectType()
		}

	case 5:
		localctx = NewTuplePrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(364)
			p.Match(TypeScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.TupleElementTypes()
		}
		{
			p.SetState(366)
			p.Match(TypeScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewQueryPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(368)
			p.TypeQuery()
		}

	case 7:
		localctx = NewThisPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(369)
			p.Match(TypeScriptParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewRedefinitionOfTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(370)
			p.TypeReference()
		}
		{
			p.SetState(371)
			p.Match(TypeScriptParserIs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)
			p.primaryType(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArrayPrimTypeContext(p, NewPrimaryTypeContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_primaryType)
			p.SetState(376)

			if !(p.Precpred(p.GetParserRuleContext(), 5)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				goto errorExit
			}
			p.SetState(377)

			if !(p.NotLineTerminator()) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
				goto errorExit
			}
			{
				p.SetState(378)
				p.Match(TypeScriptParserOpenBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(379)
				p.Match(TypeScriptParserCloseBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredefinedTypeContext is an interface to support dynamic dispatch.
type IPredefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Any() antlr.TerminalNode
	Number() antlr.TerminalNode
	Boolean() antlr.TerminalNode
	String_() antlr.TerminalNode
	Symbol() antlr.TerminalNode
	Void() antlr.TerminalNode

	// IsPredefinedTypeContext differentiates from other interfaces.
	IsPredefinedTypeContext()
}

type PredefinedTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefinedTypeContext() *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_predefinedType
	return p
}

func InitEmptyPredefinedTypeContext(p *PredefinedTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_predefinedType
}

func (*PredefinedTypeContext) IsPredefinedTypeContext() {}

func NewPredefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_predefinedType

	return p
}

func (s *PredefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefinedTypeContext) Any() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAny, 0)
}

func (s *PredefinedTypeContext) Number() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNumber, 0)
}

func (s *PredefinedTypeContext) Boolean() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBoolean, 0)
}

func (s *PredefinedTypeContext) String_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserString_, 0)
}

func (s *PredefinedTypeContext) Symbol() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSymbol, 0)
}

func (s *PredefinedTypeContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *PredefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPredefinedType(s)
	}
}

func (s *PredefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPredefinedType(s)
	}
}

func (s *PredefinedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPredefinedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PredefinedType() (localctx IPredefinedTypeContext) {
	localctx = NewPredefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, TypeScriptParserRULE_predefinedType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&1065151889409) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	NestedTypeGeneric() INestedTypeGenericContext

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeReference
	return p
}

func InitEmptyTypeReferenceContext(p *TypeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeReference
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeReferenceContext) NestedTypeGeneric() INestedTypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedTypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedTypeGenericContext)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (s *TypeReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeReference() (localctx ITypeReferenceContext) {
	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, TypeScriptParserRULE_typeReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.TypeName()
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(388)
			p.NestedTypeGeneric()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedTypeGenericContext is an interface to support dynamic dispatch.
type INestedTypeGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIncludeGeneric() ITypeIncludeGenericContext
	TypeGeneric() ITypeGenericContext

	// IsNestedTypeGenericContext differentiates from other interfaces.
	IsNestedTypeGenericContext()
}

type NestedTypeGenericContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedTypeGenericContext() *NestedTypeGenericContext {
	var p = new(NestedTypeGenericContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_nestedTypeGeneric
	return p
}

func InitEmptyNestedTypeGenericContext(p *NestedTypeGenericContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_nestedTypeGeneric
}

func (*NestedTypeGenericContext) IsNestedTypeGenericContext() {}

func NewNestedTypeGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedTypeGenericContext {
	var p = new(NestedTypeGenericContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_nestedTypeGeneric

	return p
}

func (s *NestedTypeGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedTypeGenericContext) TypeIncludeGeneric() ITypeIncludeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIncludeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIncludeGenericContext)
}

func (s *NestedTypeGenericContext) TypeGeneric() ITypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeGenericContext)
}

func (s *NestedTypeGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedTypeGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedTypeGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNestedTypeGeneric(s)
	}
}

func (s *NestedTypeGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNestedTypeGeneric(s)
	}
}

func (s *NestedTypeGenericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNestedTypeGeneric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) NestedTypeGeneric() (localctx INestedTypeGenericContext) {
	localctx = NewNestedTypeGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, TypeScriptParserRULE_nestedTypeGeneric)
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(391)
			p.TypeIncludeGeneric()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.TypeGeneric()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeGenericContext is an interface to support dynamic dispatch.
type ITypeGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LessThan() antlr.TerminalNode
	TypeArgumentList() ITypeArgumentListContext
	MoreThan() antlr.TerminalNode

	// IsTypeGenericContext differentiates from other interfaces.
	IsTypeGenericContext()
}

type TypeGenericContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeGenericContext() *TypeGenericContext {
	var p = new(TypeGenericContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeGeneric
	return p
}

func InitEmptyTypeGenericContext(p *TypeGenericContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeGeneric
}

func (*TypeGenericContext) IsTypeGenericContext() {}

func NewTypeGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeGenericContext {
	var p = new(TypeGenericContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeGeneric

	return p
}

func (s *TypeGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeGenericContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeGenericContext) TypeArgumentList() ITypeArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeGenericContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeGeneric(s)
	}
}

func (s *TypeGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeGeneric(s)
	}
}

func (s *TypeGenericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeGeneric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeGeneric() (localctx ITypeGenericContext) {
	localctx = NewTypeGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, TypeScriptParserRULE_typeGeneric)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(TypeScriptParserLessThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(396)
		p.TypeArgumentList()
	}
	{
		p.SetState(397)
		p.Match(TypeScriptParserMoreThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIncludeGenericContext is an interface to support dynamic dispatch.
type ITypeIncludeGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLessThan() []antlr.TerminalNode
	LessThan(i int) antlr.TerminalNode
	AllTypeArgumentList() []ITypeArgumentListContext
	TypeArgumentList(i int) ITypeArgumentListContext
	AllMoreThan() []antlr.TerminalNode
	MoreThan(i int) antlr.TerminalNode
	BindingPattern() IBindingPatternContext
	RightShiftArithmetic() antlr.TerminalNode

	// IsTypeIncludeGenericContext differentiates from other interfaces.
	IsTypeIncludeGenericContext()
}

type TypeIncludeGenericContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIncludeGenericContext() *TypeIncludeGenericContext {
	var p = new(TypeIncludeGenericContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeIncludeGeneric
	return p
}

func InitEmptyTypeIncludeGenericContext(p *TypeIncludeGenericContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeIncludeGeneric
}

func (*TypeIncludeGenericContext) IsTypeIncludeGenericContext() {}

func NewTypeIncludeGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIncludeGenericContext {
	var p = new(TypeIncludeGenericContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeIncludeGeneric

	return p
}

func (s *TypeIncludeGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIncludeGenericContext) AllLessThan() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserLessThan)
}

func (s *TypeIncludeGenericContext) LessThan(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, i)
}

func (s *TypeIncludeGenericContext) AllTypeArgumentList() []ITypeArgumentListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentListContext); ok {
			tst[i] = t.(ITypeArgumentListContext)
			i++
		}
	}

	return tst
}

func (s *TypeIncludeGenericContext) TypeArgumentList(i int) ITypeArgumentListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeIncludeGenericContext) AllMoreThan() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserMoreThan)
}

func (s *TypeIncludeGenericContext) MoreThan(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, i)
}

func (s *TypeIncludeGenericContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *TypeIncludeGenericContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmetic, 0)
}

func (s *TypeIncludeGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIncludeGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIncludeGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeIncludeGeneric(s)
	}
}

func (s *TypeIncludeGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeIncludeGeneric(s)
	}
}

func (s *TypeIncludeGenericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeIncludeGeneric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeIncludeGeneric() (localctx ITypeIncludeGenericContext) {
	localctx = NewTypeIncludeGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, TypeScriptParserRULE_typeIncludeGeneric)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Match(TypeScriptParserLessThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(400)
		p.TypeArgumentList()
	}
	{
		p.SetState(401)
		p.Match(TypeScriptParserLessThan)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(402)
		p.TypeArgumentList()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserMoreThan:
		{
			p.SetState(403)
			p.Match(TypeScriptParserMoreThan)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(404)
			p.BindingPattern()
		}
		{
			p.SetState(405)
			p.Match(TypeScriptParserMoreThan)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserRightShiftArithmetic:
		{
			p.SetState(407)
			p.Match(TypeScriptParserRightShiftArithmetic)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	NamespaceName() INamespaceNameContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeNameContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, TypeScriptParserRULE_typeName)
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(411)
			p.NamespaceName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectTypeContext is an interface to support dynamic dispatch.
type IObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	TypeBody() ITypeBodyContext

	// IsObjectTypeContext differentiates from other interfaces.
	IsObjectTypeContext()
}

type ObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeContext() *ObjectTypeContext {
	var p = new(ObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectType
	return p
}

func InitEmptyObjectTypeContext(p *ObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectType
}

func (*ObjectTypeContext) IsObjectTypeContext() {}

func NewObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeContext {
	var p = new(ObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_objectType

	return p
}

func (s *ObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ObjectTypeContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ObjectTypeContext) TypeBody() ITypeBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBodyContext)
}

func (s *ObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectType(s)
	}
}

func (s *ObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectType(s)
	}
}

func (s *ObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ObjectType() (localctx IObjectTypeContext) {
	localctx = NewObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, TypeScriptParserRULE_objectType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795945222064) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&3517012241796825087) != 0) {
		{
			p.SetState(415)
			p.TypeBody()
		}

	}
	{
		p.SetState(418)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeBodyContext is an interface to support dynamic dispatch.
type ITypeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeMemberList() ITypeMemberListContext
	SemiColon() antlr.TerminalNode
	Comma() antlr.TerminalNode

	// IsTypeBodyContext differentiates from other interfaces.
	IsTypeBodyContext()
}

type TypeBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBodyContext() *TypeBodyContext {
	var p = new(TypeBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeBody
	return p
}

func InitEmptyTypeBodyContext(p *TypeBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeBody
}

func (*TypeBodyContext) IsTypeBodyContext() {}

func NewTypeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBodyContext {
	var p = new(TypeBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeBody

	return p
}

func (s *TypeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBodyContext) TypeMemberList() ITypeMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberListContext)
}

func (s *TypeBodyContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *TypeBodyContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *TypeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeBody(s)
	}
}

func (s *TypeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeBody(s)
	}
}

func (s *TypeBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeBody() (localctx ITypeBodyContext) {
	localctx = NewTypeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, TypeScriptParserRULE_typeBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.TypeMemberList()
	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserSemiColon || _la == TypeScriptParserComma {
		{
			p.SetState(421)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TypeScriptParserSemiColon || _la == TypeScriptParserComma) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeMemberListContext is an interface to support dynamic dispatch.
type ITypeMemberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeMember() []ITypeMemberContext
	TypeMember(i int) ITypeMemberContext
	AllSemiColon() []antlr.TerminalNode
	SemiColon(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTypeMemberListContext differentiates from other interfaces.
	IsTypeMemberListContext()
}

type TypeMemberListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberListContext() *TypeMemberListContext {
	var p = new(TypeMemberListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMemberList
	return p
}

func InitEmptyTypeMemberListContext(p *TypeMemberListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMemberList
}

func (*TypeMemberListContext) IsTypeMemberListContext() {}

func NewTypeMemberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberListContext {
	var p = new(TypeMemberListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeMemberList

	return p
}

func (s *TypeMemberListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberListContext) AllTypeMember() []ITypeMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeMemberContext); ok {
			len++
		}
	}

	tst := make([]ITypeMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeMemberContext); ok {
			tst[i] = t.(ITypeMemberContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberListContext) TypeMember(i int) ITypeMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberContext)
}

func (s *TypeMemberListContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *TypeMemberListContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *TypeMemberListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeMemberListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeMemberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeMemberList(s)
	}
}

func (s *TypeMemberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeMemberList(s)
	}
}

func (s *TypeMemberListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeMemberList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeMemberList() (localctx ITypeMemberListContext) {
	localctx = NewTypeMemberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, TypeScriptParserRULE_typeMemberList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.TypeMember()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(425)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TypeScriptParserSemiColon || _la == TypeScriptParserComma) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(426)
				p.TypeMember()
			}

		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeMemberContext is an interface to support dynamic dispatch.
type ITypeMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertySignatur() IPropertySignaturContext
	CallSignature() ICallSignatureContext
	ConstructSignature() IConstructSignatureContext
	IndexSignature() IIndexSignatureContext
	MethodSignature() IMethodSignatureContext
	ARROW() antlr.TerminalNode
	Type_() IType_Context

	// IsTypeMemberContext differentiates from other interfaces.
	IsTypeMemberContext()
}

type TypeMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberContext() *TypeMemberContext {
	var p = new(TypeMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMember
	return p
}

func InitEmptyTypeMemberContext(p *TypeMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMember
}

func (*TypeMemberContext) IsTypeMemberContext() {}

func NewTypeMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberContext {
	var p = new(TypeMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeMember

	return p
}

func (s *TypeMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberContext) PropertySignatur() IPropertySignaturContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertySignaturContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertySignaturContext)
}

func (s *TypeMemberContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *TypeMemberContext) ConstructSignature() IConstructSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructSignatureContext)
}

func (s *TypeMemberContext) IndexSignature() IIndexSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexSignatureContext)
}

func (s *TypeMemberContext) MethodSignature() IMethodSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodSignatureContext)
}

func (s *TypeMemberContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *TypeMemberContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeMember(s)
	}
}

func (s *TypeMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeMember(s)
	}
}

func (s *TypeMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeMember() (localctx ITypeMemberContext) {
	localctx = NewTypeMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, TypeScriptParserRULE_typeMember)
	var _la int

	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.PropertySignatur()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.CallSignature()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(434)
			p.ConstructSignature()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(435)
			p.IndexSignature()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(436)
			p.MethodSignature()
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserARROW {
			{
				p.SetState(437)
				p.Match(TypeScriptParserARROW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(438)
				p.Type_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryType() IPrimaryTypeContext
	OpenBracket() antlr.TerminalNode
	CloseBracket() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ArrayTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, TypeScriptParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.primaryType(0)
	}
	p.SetState(444)

	if !(p.NotLineTerminator()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
		goto errorExit
	}
	{
		p.SetState(445)
		p.Match(TypeScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)
		p.Match(TypeScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	TupleElementTypes() ITupleElementTypesContext
	CloseBracket() antlr.TerminalNode

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *TupleTypeContext) TupleElementTypes() ITupleElementTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementTypesContext)
}

func (s *TupleTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, TypeScriptParserRULE_tupleType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.Match(TypeScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(449)
		p.TupleElementTypes()
	}
	{
		p.SetState(450)
		p.Match(TypeScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleElementTypesContext is an interface to support dynamic dispatch.
type ITupleElementTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []IType_Context
	Type_(i int) IType_Context
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTupleElementTypesContext differentiates from other interfaces.
	IsTupleElementTypesContext()
}

type TupleElementTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementTypesContext() *TupleElementTypesContext {
	var p = new(TupleElementTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleElementTypes
	return p
}

func InitEmptyTupleElementTypesContext(p *TupleElementTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleElementTypes
}

func (*TupleElementTypesContext) IsTupleElementTypesContext() {}

func NewTupleElementTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementTypesContext {
	var p = new(TupleElementTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tupleElementTypes

	return p
}

func (s *TupleElementTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementTypesContext) AllType_() []IType_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_Context); ok {
			len++
		}
	}

	tst := make([]IType_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_Context); ok {
			tst[i] = t.(IType_Context)
			i++
		}
	}

	return tst
}

func (s *TupleElementTypesContext) Type_(i int) IType_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TupleElementTypesContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TupleElementTypesContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TupleElementTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleElementTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTupleElementTypes(s)
	}
}

func (s *TupleElementTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTupleElementTypes(s)
	}
}

func (s *TupleElementTypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTupleElementTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TupleElementTypes() (localctx ITupleElementTypesContext) {
	localctx = NewTupleElementTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, TypeScriptParserRULE_tupleElementTypes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(452)
		p.Type_()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(453)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.Type_()
		}

		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	Type_() IType_Context
	TypeParameters() ITypeParametersContext
	ParameterList() IParameterListContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *FunctionTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *FunctionTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionTypeContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionTypeContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, TypeScriptParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(460)
			p.TypeParameters()
		}

	}
	{
		p.SetState(463)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4503599627370430192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&1787629984886554623) != 0) {
		{
			p.SetState(464)
			p.ParameterList()
		}

	}
	{
		p.SetState(467)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)
		p.Match(TypeScriptParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(469)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorTypeContext is an interface to support dynamic dispatch.
type IConstructorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	Type_() IType_Context
	TypeParameters() ITypeParametersContext
	ParameterList() IParameterListContext

	// IsConstructorTypeContext differentiates from other interfaces.
	IsConstructorTypeContext()
}

type ConstructorTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorTypeContext() *ConstructorTypeContext {
	var p = new(ConstructorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorType
	return p
}

func InitEmptyConstructorTypeContext(p *ConstructorTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorType
}

func (*ConstructorTypeContext) IsConstructorTypeContext() {}

func NewConstructorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorTypeContext {
	var p = new(ConstructorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructorType

	return p
}

func (s *ConstructorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorTypeContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *ConstructorTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructorTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructorTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *ConstructorTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstructorTypeContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructorTypeContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ConstructorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructorType(s)
	}
}

func (s *ConstructorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructorType(s)
	}
}

func (s *ConstructorTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitConstructorType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ConstructorType() (localctx IConstructorTypeContext) {
	localctx = NewConstructorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, TypeScriptParserRULE_constructorType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(TypeScriptParserNew)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(472)
			p.TypeParameters()
		}

	}
	{
		p.SetState(475)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4503599627370430192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&1787629984886554623) != 0) {
		{
			p.SetState(476)
			p.ParameterList()
		}

	}
	{
		p.SetState(479)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(480)
		p.Match(TypeScriptParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeQueryContext is an interface to support dynamic dispatch.
type ITypeQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Typeof() antlr.TerminalNode
	TypeQueryExpression() ITypeQueryExpressionContext

	// IsTypeQueryContext differentiates from other interfaces.
	IsTypeQueryContext()
}

type TypeQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQueryContext() *TypeQueryContext {
	var p = new(TypeQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQuery
	return p
}

func InitEmptyTypeQueryContext(p *TypeQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQuery
}

func (*TypeQueryContext) IsTypeQueryContext() {}

func NewTypeQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQueryContext {
	var p = new(TypeQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeQuery

	return p
}

func (s *TypeQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQueryContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *TypeQueryContext) TypeQueryExpression() ITypeQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQueryExpressionContext)
}

func (s *TypeQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeQuery(s)
	}
}

func (s *TypeQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeQuery(s)
	}
}

func (s *TypeQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeQuery() (localctx ITypeQueryContext) {
	localctx = NewTypeQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, TypeScriptParserRULE_typeQuery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(TypeScriptParserTypeof)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(484)
		p.TypeQueryExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeQueryExpressionContext is an interface to support dynamic dispatch.
type ITypeQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode

	// IsTypeQueryExpressionContext differentiates from other interfaces.
	IsTypeQueryExpressionContext()
}

type TypeQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQueryExpressionContext() *TypeQueryExpressionContext {
	var p = new(TypeQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQueryExpression
	return p
}

func InitEmptyTypeQueryExpressionContext(p *TypeQueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQueryExpression
}

func (*TypeQueryExpressionContext) IsTypeQueryExpressionContext() {}

func NewTypeQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQueryExpressionContext {
	var p = new(TypeQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeQueryExpression

	return p
}

func (s *TypeQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQueryExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeQueryExpressionContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *TypeQueryExpressionContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *TypeQueryExpressionContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserDot)
}

func (s *TypeQueryExpressionContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, i)
}

func (s *TypeQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeQueryExpression(s)
	}
}

func (s *TypeQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeQueryExpression(s)
	}
}

func (s *TypeQueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeQueryExpression() (localctx ITypeQueryExpressionContext) {
	localctx = NewTypeQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, TypeScriptParserRULE_typeQueryExpression)
	var _alt int

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(486)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(487)
					p.IdentifierName()
				}
				{
					p.SetState(488)
					p.Match(TypeScriptParserDot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(492)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.IdentifierName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertySignaturContext is an interface to support dynamic dispatch.
type IPropertySignaturContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	ReadOnly() antlr.TerminalNode
	QuestionMark() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	ARROW() antlr.TerminalNode
	Type_() IType_Context

	// IsPropertySignaturContext differentiates from other interfaces.
	IsPropertySignaturContext()
}

type PropertySignaturContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySignaturContext() *PropertySignaturContext {
	var p = new(PropertySignaturContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertySignatur
	return p
}

func InitEmptyPropertySignaturContext(p *PropertySignaturContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertySignatur
}

func (*PropertySignaturContext) IsPropertySignaturContext() {}

func NewPropertySignaturContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySignaturContext {
	var p = new(PropertySignaturContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertySignatur

	return p
}

func (s *PropertySignaturContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySignaturContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertySignaturContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *PropertySignaturContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *PropertySignaturContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *PropertySignaturContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *PropertySignaturContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PropertySignaturContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySignaturContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySignaturContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertySignatur(s)
	}
}

func (s *PropertySignaturContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertySignatur(s)
	}
}

func (s *PropertySignaturContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertySignatur(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PropertySignatur() (localctx IPropertySignaturContext) {
	localctx = NewPropertySignaturContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, TypeScriptParserRULE_propertySignatur)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(499)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(498)
			p.Match(TypeScriptParserReadOnly)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(501)
		p.PropertyName()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserQuestionMark {
		{
			p.SetState(502)
			p.Match(TypeScriptParserQuestionMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(505)
			p.TypeAnnotation()
		}

	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserARROW {
		{
			p.SetState(508)
			p.Match(TypeScriptParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Colon() antlr.TerminalNode
	Type_() IType_Context

	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *TypeAnnotationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, TypeScriptParserRULE_typeAnnotation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(TypeScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(513)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallSignatureContext is an interface to support dynamic dispatch.
type ICallSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	ParameterList() IParameterListContext
	TypeAnnotation() ITypeAnnotationContext

	// IsCallSignatureContext differentiates from other interfaces.
	IsCallSignatureContext()
}

type CallSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSignatureContext() *CallSignatureContext {
	var p = new(CallSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_callSignature
	return p
}

func InitEmptyCallSignatureContext(p *CallSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_callSignature
}

func (*CallSignatureContext) IsCallSignatureContext() {}

func NewCallSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSignatureContext {
	var p = new(CallSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_callSignature

	return p
}

func (s *CallSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSignatureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *CallSignatureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *CallSignatureContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *CallSignatureContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CallSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *CallSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCallSignature(s)
	}
}

func (s *CallSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCallSignature(s)
	}
}

func (s *CallSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCallSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) CallSignature() (localctx ICallSignatureContext) {
	localctx = NewCallSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, TypeScriptParserRULE_callSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(515)
			p.TypeParameters()
		}

	}
	{
		p.SetState(518)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4503599627370430192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&1787629984886554623) != 0) {
		{
			p.SetState(519)
			p.ParameterList()
		}

	}
	{
		p.SetState(522)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(523)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RestParameter() IRestParameterContext
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) RestParameter() IRestParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestParameterContext)
}

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, TypeScriptParserRULE_parameterList)
	var _la int

	var _alt int

	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(526)
			p.RestParameter()
		}

	case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace, TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule, TypeScriptParserAt, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(527)
			p.Parameter()
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(528)
					p.Match(TypeScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(529)
					p.Parameter()
				}

			}
			p.SetState(534)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(535)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(536)
				p.RestParameter()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequiredParameterListContext is an interface to support dynamic dispatch.
type IRequiredParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRequiredParameter() []IRequiredParameterContext
	RequiredParameter(i int) IRequiredParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRequiredParameterListContext differentiates from other interfaces.
	IsRequiredParameterListContext()
}

type RequiredParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredParameterListContext() *RequiredParameterListContext {
	var p = new(RequiredParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameterList
	return p
}

func InitEmptyRequiredParameterListContext(p *RequiredParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameterList
}

func (*RequiredParameterListContext) IsRequiredParameterListContext() {}

func NewRequiredParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredParameterListContext {
	var p = new(RequiredParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_requiredParameterList

	return p
}

func (s *RequiredParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredParameterListContext) AllRequiredParameter() []IRequiredParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			len++
		}
	}

	tst := make([]IRequiredParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequiredParameterContext); ok {
			tst[i] = t.(IRequiredParameterContext)
			i++
		}
	}

	return tst
}

func (s *RequiredParameterListContext) RequiredParameter(i int) IRequiredParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiredParameterContext)
}

func (s *RequiredParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *RequiredParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *RequiredParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRequiredParameterList(s)
	}
}

func (s *RequiredParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRequiredParameterList(s)
	}
}

func (s *RequiredParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRequiredParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) RequiredParameterList() (localctx IRequiredParameterListContext) {
	localctx = NewRequiredParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, TypeScriptParserRULE_requiredParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.RequiredParameter()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(542)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.RequiredParameter()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RequiredParameter() IRequiredParameterContext
	OptionalParameter() IOptionalParameterContext

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) RequiredParameter() IRequiredParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiredParameterContext)
}

func (s *ParameterContext) OptionalParameter() IOptionalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalParameterContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, TypeScriptParserRULE_parameter)
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(549)
			p.RequiredParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(550)
			p.OptionalParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionalParameterContext is an interface to support dynamic dispatch.
type IOptionalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrPattern() IIdentifierOrPatternContext
	DecoratorList() IDecoratorListContext
	QuestionMark() antlr.TerminalNode
	Initializer() IInitializerContext
	AccessibilityModifier() IAccessibilityModifierContext
	TypeAnnotation() ITypeAnnotationContext

	// IsOptionalParameterContext differentiates from other interfaces.
	IsOptionalParameterContext()
}

type OptionalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalParameterContext() *OptionalParameterContext {
	var p = new(OptionalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_optionalParameter
	return p
}

func InitEmptyOptionalParameterContext(p *OptionalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_optionalParameter
}

func (*OptionalParameterContext) IsOptionalParameterContext() {}

func NewOptionalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalParameterContext {
	var p = new(OptionalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_optionalParameter

	return p
}

func (s *OptionalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalParameterContext) IdentifierOrPattern() IIdentifierOrPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrPatternContext)
}

func (s *OptionalParameterContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *OptionalParameterContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *OptionalParameterContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *OptionalParameterContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *OptionalParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *OptionalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterOptionalParameter(s)
	}
}

func (s *OptionalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitOptionalParameter(s)
	}
}

func (s *OptionalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitOptionalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) OptionalParameter() (localctx IOptionalParameterContext) {
	localctx = NewOptionalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, TypeScriptParserRULE_optionalParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(553)
			p.DecoratorList()
		}

	}

	p.SetState(557)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(556)
			p.AccessibilityModifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(559)
		p.IdentifierOrPattern()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserQuestionMark:
		{
			p.SetState(560)
			p.Match(TypeScriptParserQuestionMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(561)
				p.TypeAnnotation()
			}

		}

	case TypeScriptParserAssign, TypeScriptParserColon:
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(564)
				p.TypeAnnotation()
			}

		}
		{
			p.SetState(567)
			p.Initializer()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestParameterContext is an interface to support dynamic dispatch.
type IRestParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ellipsis() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	TypeAnnotation() ITypeAnnotationContext

	// IsRestParameterContext differentiates from other interfaces.
	IsRestParameterContext()
}

type RestParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestParameterContext() *RestParameterContext {
	var p = new(RestParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_restParameter
	return p
}

func InitEmptyRestParameterContext(p *RestParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_restParameter
}

func (*RestParameterContext) IsRestParameterContext() {}

func NewRestParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestParameterContext {
	var p = new(RestParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_restParameter

	return p
}

func (s *RestParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RestParameterContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *RestParameterContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RestParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *RestParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRestParameter(s)
	}
}

func (s *RestParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRestParameter(s)
	}
}

func (s *RestParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRestParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) RestParameter() (localctx IRestParameterContext) {
	localctx = NewRestParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, TypeScriptParserRULE_restParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Match(TypeScriptParserEllipsis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(571)
		p.singleExpression(0)
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(572)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequiredParameterContext is an interface to support dynamic dispatch.
type IRequiredParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrPattern() IIdentifierOrPatternContext
	DecoratorList() IDecoratorListContext
	AccessibilityModifier() IAccessibilityModifierContext
	TypeAnnotation() ITypeAnnotationContext

	// IsRequiredParameterContext differentiates from other interfaces.
	IsRequiredParameterContext()
}

type RequiredParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredParameterContext() *RequiredParameterContext {
	var p = new(RequiredParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameter
	return p
}

func InitEmptyRequiredParameterContext(p *RequiredParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameter
}

func (*RequiredParameterContext) IsRequiredParameterContext() {}

func NewRequiredParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredParameterContext {
	var p = new(RequiredParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_requiredParameter

	return p
}

func (s *RequiredParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredParameterContext) IdentifierOrPattern() IIdentifierOrPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrPatternContext)
}

func (s *RequiredParameterContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *RequiredParameterContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *RequiredParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *RequiredParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRequiredParameter(s)
	}
}

func (s *RequiredParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRequiredParameter(s)
	}
}

func (s *RequiredParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRequiredParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) RequiredParameter() (localctx IRequiredParameterContext) {
	localctx = NewRequiredParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, TypeScriptParserRULE_requiredParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(575)
			p.DecoratorList()
		}

	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(578)
			p.AccessibilityModifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(581)
		p.IdentifierOrPattern()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(582)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessibilityModifierContext is an interface to support dynamic dispatch.
type IAccessibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Public() antlr.TerminalNode
	Private() antlr.TerminalNode
	Protected() antlr.TerminalNode

	// IsAccessibilityModifierContext differentiates from other interfaces.
	IsAccessibilityModifierContext()
}

type AccessibilityModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessibilityModifierContext() *AccessibilityModifierContext {
	var p = new(AccessibilityModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_accessibilityModifier
	return p
}

func InitEmptyAccessibilityModifierContext(p *AccessibilityModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_accessibilityModifier
}

func (*AccessibilityModifierContext) IsAccessibilityModifierContext() {}

func NewAccessibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessibilityModifierContext {
	var p = new(AccessibilityModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_accessibilityModifier

	return p
}

func (s *AccessibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessibilityModifierContext) Public() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPublic, 0)
}

func (s *AccessibilityModifierContext) Private() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPrivate, 0)
}

func (s *AccessibilityModifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserProtected, 0)
}

func (s *AccessibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAccessibilityModifier(s)
	}
}

func (s *AccessibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAccessibilityModifier(s)
	}
}

func (s *AccessibilityModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAccessibilityModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) AccessibilityModifier() (localctx IAccessibilityModifierContext) {
	localctx = NewAccessibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, TypeScriptParserRULE_accessibilityModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&19) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrPatternContext is an interface to support dynamic dispatch.
type IIdentifierOrPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	BindingPattern() IBindingPatternContext

	// IsIdentifierOrPatternContext differentiates from other interfaces.
	IsIdentifierOrPatternContext()
}

type IdentifierOrPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrPatternContext() *IdentifierOrPatternContext {
	var p = new(IdentifierOrPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierOrPattern
	return p
}

func InitEmptyIdentifierOrPatternContext(p *IdentifierOrPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierOrPattern
}

func (*IdentifierOrPatternContext) IsIdentifierOrPatternContext() {}

func NewIdentifierOrPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrPatternContext {
	var p = new(IdentifierOrPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_identifierOrPattern

	return p
}

func (s *IdentifierOrPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrPatternContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *IdentifierOrPatternContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *IdentifierOrPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierOrPattern(s)
	}
}

func (s *IdentifierOrPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierOrPattern(s)
	}
}

func (s *IdentifierOrPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIdentifierOrPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IdentifierOrPattern() (localctx IIdentifierOrPatternContext) {
	localctx = NewIdentifierOrPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, TypeScriptParserRULE_identifierOrPattern)
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(587)
			p.IdentifierName()
		}

	case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(588)
			p.BindingPattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructSignatureContext is an interface to support dynamic dispatch.
type IConstructSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	ParameterList() IParameterListContext
	TypeAnnotation() ITypeAnnotationContext

	// IsConstructSignatureContext differentiates from other interfaces.
	IsConstructSignatureContext()
}

type ConstructSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructSignatureContext() *ConstructSignatureContext {
	var p = new(ConstructSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructSignature
	return p
}

func InitEmptyConstructSignatureContext(p *ConstructSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructSignature
}

func (*ConstructSignatureContext) IsConstructSignatureContext() {}

func NewConstructSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructSignatureContext {
	var p = new(ConstructSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructSignature

	return p
}

func (s *ConstructSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructSignatureContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *ConstructSignatureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructSignatureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructSignatureContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructSignatureContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ConstructSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ConstructSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructSignature(s)
	}
}

func (s *ConstructSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructSignature(s)
	}
}

func (s *ConstructSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitConstructSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ConstructSignature() (localctx IConstructSignatureContext) {
	localctx = NewConstructSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, TypeScriptParserRULE_constructSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(TypeScriptParserNew)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(592)
			p.TypeParameters()
		}

	}
	{
		p.SetState(595)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4503599627370430192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&1787629984886554623) != 0) {
		{
			p.SetState(596)
			p.ParameterList()
		}

	}
	{
		p.SetState(599)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(600)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexSignatureContext is an interface to support dynamic dispatch.
type IIndexSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Colon() antlr.TerminalNode
	CloseBracket() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	Number() antlr.TerminalNode
	String_() antlr.TerminalNode

	// IsIndexSignatureContext differentiates from other interfaces.
	IsIndexSignatureContext()
}

type IndexSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexSignatureContext() *IndexSignatureContext {
	var p = new(IndexSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexSignature
	return p
}

func InitEmptyIndexSignatureContext(p *IndexSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexSignature
}

func (*IndexSignatureContext) IsIndexSignatureContext() {}

func NewIndexSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexSignatureContext {
	var p = new(IndexSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_indexSignature

	return p
}

func (s *IndexSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexSignatureContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *IndexSignatureContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *IndexSignatureContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *IndexSignatureContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *IndexSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *IndexSignatureContext) Number() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNumber, 0)
}

func (s *IndexSignatureContext) String_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserString_, 0)
}

func (s *IndexSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIndexSignature(s)
	}
}

func (s *IndexSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIndexSignature(s)
	}
}

func (s *IndexSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIndexSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IndexSignature() (localctx IIndexSignatureContext) {
	localctx = NewIndexSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, TypeScriptParserRULE_indexSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Match(TypeScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(604)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(605)
		p.Match(TypeScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(606)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TypeScriptParserNumber || _la == TypeScriptParserString_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(607)
		p.Match(TypeScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(608)
		p.TypeAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodSignatureContext is an interface to support dynamic dispatch.
type IMethodSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	CallSignature() ICallSignatureContext
	QuestionMark() antlr.TerminalNode

	// IsMethodSignatureContext differentiates from other interfaces.
	IsMethodSignatureContext()
}

type MethodSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSignatureContext() *MethodSignatureContext {
	var p = new(MethodSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_methodSignature
	return p
}

func InitEmptyMethodSignatureContext(p *MethodSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_methodSignature
}

func (*MethodSignatureContext) IsMethodSignatureContext() {}

func NewMethodSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSignatureContext {
	var p = new(MethodSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_methodSignature

	return p
}

func (s *MethodSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSignatureContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodSignatureContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *MethodSignatureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *MethodSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMethodSignature(s)
	}
}

func (s *MethodSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMethodSignature(s)
	}
}

func (s *MethodSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMethodSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) MethodSignature() (localctx IMethodSignatureContext) {
	localctx = NewMethodSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, TypeScriptParserRULE_methodSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.PropertyName()
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserQuestionMark {
		{
			p.SetState(611)
			p.Match(TypeScriptParserQuestionMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(614)
		p.CallSignature()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasDeclarationContext is an interface to support dynamic dispatch.
type ITypeAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeAlias() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Assign() antlr.TerminalNode
	Type_() IType_Context
	SemiColon() antlr.TerminalNode
	TypeParameters() ITypeParametersContext

	// IsTypeAliasDeclarationContext differentiates from other interfaces.
	IsTypeAliasDeclarationContext()
}

type TypeAliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasDeclarationContext() *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAliasDeclaration
	return p
}

func InitEmptyTypeAliasDeclarationContext(p *TypeAliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAliasDeclaration
}

func (*TypeAliasDeclarationContext) IsTypeAliasDeclarationContext() {}

func NewTypeAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeAliasDeclaration

	return p
}

func (s *TypeAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasDeclarationContext) TypeAlias() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeAlias, 0)
}

func (s *TypeAliasDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeAliasDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *TypeAliasDeclarationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAliasDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *TypeAliasDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeAliasDeclaration(s)
	}
}

func (s *TypeAliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeAliasDeclaration(s)
	}
}

func (s *TypeAliasDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeAliasDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TypeAliasDeclaration() (localctx ITypeAliasDeclarationContext) {
	localctx = NewTypeAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, TypeScriptParserRULE_typeAliasDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.Match(TypeScriptParserTypeAlias)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(617)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(618)
			p.TypeParameters()
		}

	}
	{
		p.SetState(621)
		p.Match(TypeScriptParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Type_()
	}
	{
		p.SetState(623)
		p.Match(TypeScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constructor() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	AccessibilityModifier() IAccessibilityModifierContext
	FormalParameterList() IFormalParameterListContext
	SemiColon() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorDeclaration
	return p
}

func InitEmptyConstructorDeclarationContext(p *ConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorDeclaration
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) Constructor() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConstructor, 0)
}

func (s *ConstructorDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructorDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructorDeclarationContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *ConstructorDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstructorDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ConstructorDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ConstructorDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ConstructorDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, TypeScriptParserRULE_constructorDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&19) != 0 {
		{
			p.SetState(625)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(628)
		p.Match(TypeScriptParserConstructor)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
		{
			p.SetState(630)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(633)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(634)
			p.Match(TypeScriptParserOpenBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.FunctionBody()
		}
		{
			p.SetState(636)
			p.Match(TypeScriptParserCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(638)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Interface() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ObjectType() IObjectTypeContext
	Export() antlr.TerminalNode
	Declare() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	InterfaceExtendsClause() IInterfaceExtendsClauseContext
	SemiColon() antlr.TerminalNode

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) Interface() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInterface, 0)
}

func (s *InterfaceDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *InterfaceDeclarationContext) ObjectType() IObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *InterfaceDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *InterfaceDeclarationContext) Declare() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDeclare, 0)
}

func (s *InterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *InterfaceDeclarationContext) InterfaceExtendsClause() IInterfaceExtendsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceExtendsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceExtendsClauseContext)
}

func (s *InterfaceDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, TypeScriptParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExport {
		{
			p.SetState(641)
			p.Match(TypeScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserDeclare {
		{
			p.SetState(644)
			p.Match(TypeScriptParserDeclare)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(647)
		p.Match(TypeScriptParserInterface)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(649)
			p.TypeParameters()
		}

	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExtends {
		{
			p.SetState(652)
			p.InterfaceExtendsClause()
		}

	}
	{
		p.SetState(655)
		p.ObjectType()
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(656)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceExtendsClauseContext is an interface to support dynamic dispatch.
type IInterfaceExtendsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Extends() antlr.TerminalNode
	ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext

	// IsInterfaceExtendsClauseContext differentiates from other interfaces.
	IsInterfaceExtendsClauseContext()
}

type InterfaceExtendsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceExtendsClauseContext() *InterfaceExtendsClauseContext {
	var p = new(InterfaceExtendsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceExtendsClause
	return p
}

func InitEmptyInterfaceExtendsClauseContext(p *InterfaceExtendsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceExtendsClause
}

func (*InterfaceExtendsClauseContext) IsInterfaceExtendsClauseContext() {}

func NewInterfaceExtendsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceExtendsClauseContext {
	var p = new(InterfaceExtendsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_interfaceExtendsClause

	return p
}

func (s *InterfaceExtendsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceExtendsClauseContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *InterfaceExtendsClauseContext) ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeListContext)
}

func (s *InterfaceExtendsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceExtendsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceExtendsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInterfaceExtendsClause(s)
	}
}

func (s *InterfaceExtendsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInterfaceExtendsClause(s)
	}
}

func (s *InterfaceExtendsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitInterfaceExtendsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) InterfaceExtendsClause() (localctx IInterfaceExtendsClauseContext) {
	localctx = NewInterfaceExtendsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, TypeScriptParserRULE_interfaceExtendsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Match(TypeScriptParserExtends)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(660)
		p.ClassOrInterfaceTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceTypeListContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeReference() []ITypeReferenceContext
	TypeReference(i int) ITypeReferenceContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsClassOrInterfaceTypeListContext differentiates from other interfaces.
	IsClassOrInterfaceTypeListContext()
}

type ClassOrInterfaceTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeListContext() *ClassOrInterfaceTypeListContext {
	var p = new(ClassOrInterfaceTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classOrInterfaceTypeList
	return p
}

func InitEmptyClassOrInterfaceTypeListContext(p *ClassOrInterfaceTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classOrInterfaceTypeList
}

func (*ClassOrInterfaceTypeListContext) IsClassOrInterfaceTypeListContext() {}

func NewClassOrInterfaceTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeListContext {
	var p = new(ClassOrInterfaceTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classOrInterfaceTypeList

	return p
}

func (s *ClassOrInterfaceTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeListContext) AllTypeReference() []ITypeReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITypeReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeReferenceContext); ok {
			tst[i] = t.(ITypeReferenceContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeListContext) TypeReference(i int) ITypeReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ClassOrInterfaceTypeListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ClassOrInterfaceTypeListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ClassOrInterfaceTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassOrInterfaceTypeList(s)
	}
}

func (s *ClassOrInterfaceTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassOrInterfaceTypeList(s)
	}
}

func (s *ClassOrInterfaceTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassOrInterfaceTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassOrInterfaceTypeList() (localctx IClassOrInterfaceTypeListContext) {
	localctx = NewClassOrInterfaceTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, TypeScriptParserRULE_classOrInterfaceTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.TypeReference()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(663)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.TypeReference()
		}

		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Enum() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	Const() antlr.TerminalNode
	EnumBody() IEnumBodyContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) Enum() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEnum, 0)
}

func (s *EnumDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *EnumDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *EnumDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *EnumDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *EnumDeclarationContext) EnumBody() IEnumBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, TypeScriptParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserConst {
		{
			p.SetState(670)
			p.Match(TypeScriptParserConst)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(673)
		p.Match(TypeScriptParserEnum)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(674)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(675)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028797018963968) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&3517012241796825087) != 0) {
		{
			p.SetState(676)
			p.EnumBody()
		}

	}
	{
		p.SetState(679)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyContext is an interface to support dynamic dispatch.
type IEnumBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumMemberList() IEnumMemberListContext
	Comma() antlr.TerminalNode

	// IsEnumBodyContext differentiates from other interfaces.
	IsEnumBodyContext()
}

type EnumBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyContext() *EnumBodyContext {
	var p = new(EnumBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumBody
	return p
}

func InitEmptyEnumBodyContext(p *EnumBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumBody
}

func (*EnumBodyContext) IsEnumBodyContext() {}

func NewEnumBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyContext {
	var p = new(EnumBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumBody

	return p
}

func (s *EnumBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyContext) EnumMemberList() IEnumMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberListContext)
}

func (s *EnumBodyContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *EnumBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumBody(s)
	}
}

func (s *EnumBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumBody(s)
	}
}

func (s *EnumBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEnumBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) EnumBody() (localctx IEnumBodyContext) {
	localctx = NewEnumBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, TypeScriptParserRULE_enumBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.EnumMemberList()
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(682)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberListContext is an interface to support dynamic dispatch.
type IEnumMemberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumMember() []IEnumMemberContext
	EnumMember(i int) IEnumMemberContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsEnumMemberListContext differentiates from other interfaces.
	IsEnumMemberListContext()
}

type EnumMemberListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberListContext() *EnumMemberListContext {
	var p = new(EnumMemberListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMemberList
	return p
}

func InitEmptyEnumMemberListContext(p *EnumMemberListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMemberList
}

func (*EnumMemberListContext) IsEnumMemberListContext() {}

func NewEnumMemberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberListContext {
	var p = new(EnumMemberListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumMemberList

	return p
}

func (s *EnumMemberListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberListContext) AllEnumMember() []IEnumMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMemberContext); ok {
			len++
		}
	}

	tst := make([]IEnumMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMemberContext); ok {
			tst[i] = t.(IEnumMemberContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberListContext) EnumMember(i int) IEnumMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberContext)
}

func (s *EnumMemberListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *EnumMemberListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *EnumMemberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumMemberList(s)
	}
}

func (s *EnumMemberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumMemberList(s)
	}
}

func (s *EnumMemberListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEnumMemberList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) EnumMemberList() (localctx IEnumMemberListContext) {
	localctx = NewEnumMemberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, TypeScriptParserRULE_enumMemberList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.EnumMember()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(686)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(687)
				p.EnumMember()
			}

		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberContext is an interface to support dynamic dispatch.
type IEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsEnumMemberContext differentiates from other interfaces.
	IsEnumMemberContext()
}

type EnumMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberContext() *EnumMemberContext {
	var p = new(EnumMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMember
	return p
}

func InitEmptyEnumMemberContext(p *EnumMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMember
}

func (*EnumMemberContext) IsEnumMemberContext() {}

func NewEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberContext {
	var p = new(EnumMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumMember

	return p
}

func (s *EnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *EnumMemberContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *EnumMemberContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumMember(s)
	}
}

func (s *EnumMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumMember(s)
	}
}

func (s *EnumMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEnumMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) EnumMember() (localctx IEnumMemberContext) {
	localctx = NewEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, TypeScriptParserRULE_enumMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.PropertyName()
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAssign {
		{
			p.SetState(694)
			p.Match(TypeScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(695)
			p.singleExpression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceDeclarationContext is an interface to support dynamic dispatch.
type INamespaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Namespace() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsNamespaceDeclarationContext differentiates from other interfaces.
	IsNamespaceDeclarationContext()
}

type NamespaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceDeclarationContext() *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceDeclaration
	return p
}

func InitEmptyNamespaceDeclarationContext(p *NamespaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceDeclaration
}

func (*NamespaceDeclarationContext) IsNamespaceDeclarationContext() {}

func NewNamespaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_namespaceDeclaration

	return p
}

func (s *NamespaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDeclarationContext) Namespace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNamespace, 0)
}

func (s *NamespaceDeclarationContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NamespaceDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *NamespaceDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *NamespaceDeclarationContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *NamespaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNamespaceDeclaration(s)
	}
}

func (s *NamespaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNamespaceDeclaration(s)
	}
}

func (s *NamespaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNamespaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) NamespaceDeclaration() (localctx INamespaceDeclarationContext) {
	localctx = NewNamespaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, TypeScriptParserRULE_namespaceDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(TypeScriptParserNamespace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.NamespaceName()
	}
	{
		p.SetState(700)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(701)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(704)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNameContext is an interface to support dynamic dispatch.
type INamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []antlr.TerminalNode
	Identifier(i int) antlr.TerminalNode
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode

	// IsNamespaceNameContext differentiates from other interfaces.
	IsNamespaceNameContext()
}

type NamespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameContext() *NamespaceNameContext {
	var p = new(NamespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceName
	return p
}

func InitEmptyNamespaceNameContext(p *NamespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceName
}

func (*NamespaceNameContext) IsNamespaceNameContext() {}

func NewNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameContext {
	var p = new(NamespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_namespaceName

	return p
}

func (s *NamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserIdentifier)
}

func (s *NamespaceNameContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, i)
}

func (s *NamespaceNameContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserDot)
}

func (s *NamespaceNameContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, i)
}

func (s *NamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNamespaceName(s)
	}
}

func (s *NamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNamespaceName(s)
	}
}

func (s *NamespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNamespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) NamespaceName() (localctx INamespaceNameContext) {
	localctx = NewNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, TypeScriptParserRULE_namespaceName)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == TypeScriptParserDot {
				{
					p.SetState(707)
					p.Match(TypeScriptParserDot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(710)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(712)
				p.Match(TypeScriptParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAliasDeclarationContext is an interface to support dynamic dispatch.
type IImportAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Assign() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	SemiColon() antlr.TerminalNode

	// IsImportAliasDeclarationContext differentiates from other interfaces.
	IsImportAliasDeclarationContext()
}

type ImportAliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasDeclarationContext() *ImportAliasDeclarationContext {
	var p = new(ImportAliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importAliasDeclaration
	return p
}

func InitEmptyImportAliasDeclarationContext(p *ImportAliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importAliasDeclaration
}

func (*ImportAliasDeclarationContext) IsImportAliasDeclarationContext() {}

func NewImportAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasDeclarationContext {
	var p = new(ImportAliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importAliasDeclaration

	return p
}

func (s *ImportAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ImportAliasDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *ImportAliasDeclarationContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *ImportAliasDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ImportAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportAliasDeclaration(s)
	}
}

func (s *ImportAliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportAliasDeclaration(s)
	}
}

func (s *ImportAliasDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitImportAliasDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ImportAliasDeclaration() (localctx IImportAliasDeclarationContext) {
	localctx = NewImportAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, TypeScriptParserRULE_importAliasDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(719)
		p.Match(TypeScriptParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(720)
		p.NamespaceName()
	}
	{
		p.SetState(721)
		p.Match(TypeScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorListContext is an interface to support dynamic dispatch.
type IDecoratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecorator() []IDecoratorContext
	Decorator(i int) IDecoratorContext

	// IsDecoratorListContext differentiates from other interfaces.
	IsDecoratorListContext()
}

type DecoratorListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorListContext() *DecoratorListContext {
	var p = new(DecoratorListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorList
	return p
}

func InitEmptyDecoratorListContext(p *DecoratorListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorList
}

func (*DecoratorListContext) IsDecoratorListContext() {}

func NewDecoratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorListContext {
	var p = new(DecoratorListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorList

	return p
}

func (s *DecoratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorListContext) AllDecorator() []IDecoratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecoratorContext); ok {
			len++
		}
	}

	tst := make([]IDecoratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecoratorContext); ok {
			tst[i] = t.(IDecoratorContext)
			i++
		}
	}

	return tst
}

func (s *DecoratorListContext) Decorator(i int) IDecoratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorList(s)
	}
}

func (s *DecoratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorList(s)
	}
}

func (s *DecoratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDecoratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) DecoratorList() (localctx IDecoratorListContext) {
	localctx = NewDecoratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, TypeScriptParserRULE_decoratorList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TypeScriptParserAt {
		{
			p.SetState(723)
			p.Decorator()
		}

		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	At() antlr.TerminalNode
	DecoratorMemberExpression() IDecoratorMemberExpressionContext
	DecoratorCallExpression() IDecoratorCallExpressionContext

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decorator
	return p
}

func InitEmptyDecoratorContext(p *DecoratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decorator
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) At() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAt, 0)
}

func (s *DecoratorContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorContext) DecoratorCallExpression() IDecoratorCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorCallExpressionContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDecorator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, TypeScriptParserRULE_decorator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(TypeScriptParserAt)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(729)
			p.decoratorMemberExpression(0)
		}

	case 2:
		{
			p.SetState(730)
			p.DecoratorCallExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorMemberExpressionContext is an interface to support dynamic dispatch.
type IDecoratorMemberExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseParen() antlr.TerminalNode
	DecoratorMemberExpression() IDecoratorMemberExpressionContext
	Dot() antlr.TerminalNode
	IdentifierName() IIdentifierNameContext

	// IsDecoratorMemberExpressionContext differentiates from other interfaces.
	IsDecoratorMemberExpressionContext()
}

type DecoratorMemberExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorMemberExpressionContext() *DecoratorMemberExpressionContext {
	var p = new(DecoratorMemberExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorMemberExpression
	return p
}

func InitEmptyDecoratorMemberExpressionContext(p *DecoratorMemberExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorMemberExpression
}

func (*DecoratorMemberExpressionContext) IsDecoratorMemberExpressionContext() {}

func NewDecoratorMemberExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorMemberExpressionContext {
	var p = new(DecoratorMemberExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorMemberExpression

	return p
}

func (s *DecoratorMemberExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorMemberExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *DecoratorMemberExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *DecoratorMemberExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DecoratorMemberExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *DecoratorMemberExpressionContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorMemberExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, 0)
}

func (s *DecoratorMemberExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *DecoratorMemberExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorMemberExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorMemberExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorMemberExpression(s)
	}
}

func (s *DecoratorMemberExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorMemberExpression(s)
	}
}

func (s *DecoratorMemberExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDecoratorMemberExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) DecoratorMemberExpression() (localctx IDecoratorMemberExpressionContext) {
	return p.decoratorMemberExpression(0)
}

func (p *TypeScriptParser) decoratorMemberExpression(_p int) (localctx IDecoratorMemberExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDecoratorMemberExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDecoratorMemberExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, TypeScriptParserRULE_decoratorMemberExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		{
			p.SetState(734)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserOpenParen:
		{
			p.SetState(735)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)
			p.singleExpression(0)
		}
		{
			p.SetState(737)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDecoratorMemberExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_decoratorMemberExpression)
			p.SetState(741)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(742)
				p.Match(TypeScriptParserDot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(743)
				p.IdentifierName()
			}

		}
		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorCallExpressionContext is an interface to support dynamic dispatch.
type IDecoratorCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecoratorMemberExpression() IDecoratorMemberExpressionContext
	Arguments() IArgumentsContext

	// IsDecoratorCallExpressionContext differentiates from other interfaces.
	IsDecoratorCallExpressionContext()
}

type DecoratorCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorCallExpressionContext() *DecoratorCallExpressionContext {
	var p = new(DecoratorCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorCallExpression
	return p
}

func InitEmptyDecoratorCallExpressionContext(p *DecoratorCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorCallExpression
}

func (*DecoratorCallExpressionContext) IsDecoratorCallExpressionContext() {}

func NewDecoratorCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorCallExpressionContext {
	var p = new(DecoratorCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorCallExpression

	return p
}

func (s *DecoratorCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorCallExpressionContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorCallExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *DecoratorCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorCallExpression(s)
	}
}

func (s *DecoratorCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorCallExpression(s)
	}
}

func (s *DecoratorCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDecoratorCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) DecoratorCallExpression() (localctx IDecoratorCallExpressionContext) {
	localctx = NewDecoratorCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, TypeScriptParserRULE_decoratorCallExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.decoratorMemberExpression(0)
	}
	{
		p.SetState(750)
		p.Arguments()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SourceElements() ISourceElementsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEOF, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, TypeScriptParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(752)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(755)
		p.Match(TypeScriptParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	Export() antlr.TerminalNode

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElement
	return p
}

func InitEmptySourceElementContext(p *SourceElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElement
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (s *SourceElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSourceElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) SourceElement() (localctx ISourceElementContext) {
	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, TypeScriptParserRULE_sourceElement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(758)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(757)
			p.Match(TypeScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(760)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ImportStatement() IImportStatementContext
	ExportStatement() IExportStatementContext
	EmptyStatement_() IEmptyStatement_Context
	AbstractDeclaration() IAbstractDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	NamespaceDeclaration() INamespaceDeclarationContext
	IfStatement() IIfStatementContext
	IterationStatement() IIterationStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	ReturnStatement() IReturnStatementContext
	YieldStatement() IYieldStatementContext
	WithStatement() IWithStatementContext
	LabelledStatement() ILabelledStatementContext
	SwitchStatement() ISwitchStatementContext
	ThrowStatement() IThrowStatementContext
	TryStatement() ITryStatementContext
	DebuggerStatement() IDebuggerStatementContext
	FunctionDeclaration() IFunctionDeclarationContext
	ArrowFunctionDeclaration() IArrowFunctionDeclarationContext
	GeneratorFunctionDeclaration() IGeneratorFunctionDeclarationContext
	VariableStatement() IVariableStatementContext
	TypeAliasDeclaration() ITypeAliasDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	ExpressionStatement() IExpressionStatementContext
	Export() antlr.TerminalNode
	Statement() IStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) AbstractDeclaration() IAbstractDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclarationContext)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *StatementContext) NamespaceDeclaration() INamespaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceDeclarationContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDebuggerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ArrowFunctionDeclaration() IArrowFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionDeclarationContext)
}

func (s *StatementContext) GeneratorFunctionDeclaration() IGeneratorFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorFunctionDeclarationContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *StatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *StatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, TypeScriptParserRULE_statement)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(762)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(763)
			p.ImportStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(764)
			p.ExportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(765)
			p.EmptyStatement_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(766)
			p.AbstractDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(767)
			p.ClassDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(768)
			p.InterfaceDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(769)
			p.NamespaceDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(770)
			p.IfStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(771)
			p.IterationStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(772)
			p.ContinueStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(773)
			p.BreakStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(774)
			p.ReturnStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(775)
			p.YieldStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(776)
			p.WithStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(777)
			p.LabelledStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(778)
			p.SwitchStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(779)
			p.ThrowStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(780)
			p.TryStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(781)
			p.DebuggerStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(782)
			p.FunctionDeclaration()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(783)
			p.ArrowFunctionDeclaration()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(784)
			p.GeneratorFunctionDeclaration()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(785)
			p.VariableStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(786)
			p.TypeAliasDeclaration()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(787)
			p.EnumDeclaration()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(788)
			p.ExpressionStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(789)
			p.Match(TypeScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(790)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, TypeScriptParserRULE_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(794)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(797)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, TypeScriptParserRULE_statementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(799)
				p.Statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstractDeclarationContext is an interface to support dynamic dispatch.
type IAbstractDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Abstract() antlr.TerminalNode
	Eos() IEosContext
	Identifier() antlr.TerminalNode
	CallSignature() ICallSignatureContext
	VariableStatement() IVariableStatementContext

	// IsAbstractDeclarationContext differentiates from other interfaces.
	IsAbstractDeclarationContext()
}

type AbstractDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclarationContext() *AbstractDeclarationContext {
	var p = new(AbstractDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_abstractDeclaration
	return p
}

func InitEmptyAbstractDeclarationContext(p *AbstractDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_abstractDeclaration
}

func (*AbstractDeclarationContext) IsAbstractDeclarationContext() {}

func NewAbstractDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclarationContext {
	var p = new(AbstractDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_abstractDeclaration

	return p
}

func (s *AbstractDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclarationContext) Abstract() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAbstract, 0)
}

func (s *AbstractDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AbstractDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *AbstractDeclarationContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *AbstractDeclarationContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *AbstractDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAbstractDeclaration(s)
	}
}

func (s *AbstractDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAbstractDeclaration(s)
	}
}

func (s *AbstractDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAbstractDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) AbstractDeclaration() (localctx IAbstractDeclarationContext) {
	localctx = NewAbstractDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, TypeScriptParserRULE_abstractDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(TypeScriptParserAbstract)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(805)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(806)
			p.CallSignature()
		}

	case 2:
		{
			p.SetState(807)
			p.VariableStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(810)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Import() antlr.TerminalNode
	FromBlock() IFromBlockContext
	ImportAliasDeclaration() IImportAliasDeclarationContext

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImport, 0)
}

func (s *ImportStatementContext) FromBlock() IFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromBlockContext)
}

func (s *ImportStatementContext) ImportAliasDeclaration() IImportAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasDeclarationContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, TypeScriptParserRULE_importStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(TypeScriptParserImport)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(813)
			p.FromBlock()
		}

	case 2:
		{
			p.SetState(814)
			p.ImportAliasDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromBlockContext is an interface to support dynamic dispatch.
type IFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Eos() IEosContext
	Multiply() antlr.TerminalNode
	MultipleImportStatement() IMultipleImportStatementContext
	As() antlr.TerminalNode
	IdentifierName() IIdentifierNameContext

	// IsFromBlockContext differentiates from other interfaces.
	IsFromBlockContext()
}

type FromBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromBlockContext() *FromBlockContext {
	var p = new(FromBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_fromBlock
	return p
}

func InitEmptyFromBlockContext(p *FromBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_fromBlock
}

func (*FromBlockContext) IsFromBlockContext() {}

func NewFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromBlockContext {
	var p = new(FromBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_fromBlock

	return p
}

func (s *FromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FromBlockContext) From() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFrom, 0)
}

func (s *FromBlockContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *FromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *FromBlockContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *FromBlockContext) MultipleImportStatement() IMultipleImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleImportStatementContext)
}

func (s *FromBlockContext) As() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAs, 0)
}

func (s *FromBlockContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *FromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFromBlock(s)
	}
}

func (s *FromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFromBlock(s)
	}
}

func (s *FromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FromBlock() (localctx IFromBlockContext) {
	localctx = NewFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, TypeScriptParserRULE_fromBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserMultiply:
		{
			p.SetState(817)
			p.Match(TypeScriptParserMultiply)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserOpenBrace, TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule, TypeScriptParserIdentifier:
		{
			p.SetState(818)
			p.MultipleImportStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAs {
		{
			p.SetState(821)
			p.Match(TypeScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.IdentifierName()
		}

	}
	{
		p.SetState(825)
		p.Match(TypeScriptParserFrom)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(826)
		p.Match(TypeScriptParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(827)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipleImportStatementContext is an interface to support dynamic dispatch.
type IMultipleImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	CloseBrace() antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsMultipleImportStatementContext differentiates from other interfaces.
	IsMultipleImportStatementContext()
}

type MultipleImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleImportStatementContext() *MultipleImportStatementContext {
	var p = new(MultipleImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_multipleImportStatement
	return p
}

func InitEmptyMultipleImportStatementContext(p *MultipleImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_multipleImportStatement
}

func (*MultipleImportStatementContext) IsMultipleImportStatementContext() {}

func NewMultipleImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleImportStatementContext {
	var p = new(MultipleImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_multipleImportStatement

	return p
}

func (s *MultipleImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleImportStatementContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *MultipleImportStatementContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleImportStatementContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MultipleImportStatementContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *MultipleImportStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *MultipleImportStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *MultipleImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMultipleImportStatement(s)
	}
}

func (s *MultipleImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMultipleImportStatement(s)
	}
}

func (s *MultipleImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMultipleImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) MultipleImportStatement() (localctx IMultipleImportStatementContext) {
	localctx = NewMultipleImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, TypeScriptParserRULE_multipleImportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4503599627370496000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&1211169232583131135) != 0) {
		{
			p.SetState(829)
			p.IdentifierName()
		}
		{
			p.SetState(830)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(834)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(835)
		p.IdentifierName()
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(836)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.IdentifierName()
		}

		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(843)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Export() antlr.TerminalNode
	FromBlock() IFromBlockContext
	Statement() IStatementContext
	Default() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *ExportStatementContext) FromBlock() IFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromBlockContext)
}

func (s *ExportStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExportStatementContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, TypeScriptParserRULE_exportStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Match(TypeScriptParserExport)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(846)
			p.Match(TypeScriptParserDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(849)
			p.FromBlock()
		}

	case 2:
		{
			p.SetState(850)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingPattern() IBindingPatternContext
	Initializer() IInitializerContext
	TypeAnnotation() ITypeAnnotationContext
	SemiColon() antlr.TerminalNode
	VariableDeclarationList() IVariableDeclarationListContext
	AccessibilityModifier() IAccessibilityModifierContext
	VarModifier() IVarModifierContext
	ReadOnly() antlr.TerminalNode
	Declare() antlr.TerminalNode

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableStatement
	return p
}

func InitEmptyVariableStatementContext(p *VariableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableStatement
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *VariableStatementContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *VariableStatementContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *VariableStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *VariableStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableStatementContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *VariableStatementContext) Declare() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDeclare, 0)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, TypeScriptParserRULE_variableStatement)
	var _la int

	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(853)
			p.BindingPattern()
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(854)
				p.TypeAnnotation()
			}

		}
		{
			p.SetState(857)
			p.Initializer()
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(858)
				p.Match(TypeScriptParserSemiColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&19) != 0 {
			{
				p.SetState(861)
				p.AccessibilityModifier()
			}

		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&2281701377) != 0 {
			{
				p.SetState(864)
				p.VarModifier()
			}

		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserReadOnly {
			{
				p.SetState(867)
				p.Match(TypeScriptParserReadOnly)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(870)
			p.VariableDeclarationList()
		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(871)
				p.Match(TypeScriptParserSemiColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(874)
			p.Match(TypeScriptParserDeclare)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&2281701377) != 0 {
			{
				p.SetState(875)
				p.VarModifier()
			}

		}
		{
			p.SetState(878)
			p.VariableDeclarationList()
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(879)
				p.Match(TypeScriptParserSemiColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclarationList
	return p
}

func InitEmptyVariableDeclarationListContext(p *VariableDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclarationList
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitVariableDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, TypeScriptParserRULE_variableDeclarationList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.VariableDeclaration()
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(885)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(886)
				p.VariableDeclaration()
			}

		}
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrKeyWord() IIdentifierOrKeyWordContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext
	TypeAnnotation() ITypeAnnotationContext
	AllSingleExpression() []ISingleExpressionContext
	SingleExpression(i int) ISingleExpressionContext
	Assign() antlr.TerminalNode
	TypeParameters() ITypeParametersContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) IdentifierOrKeyWord() IIdentifierOrKeyWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrKeyWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrKeyWordContext)
}

func (s *VariableDeclarationContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *VariableDeclarationContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *VariableDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *VariableDeclarationContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, TypeScriptParserRULE_variableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserTypeAlias, TypeScriptParserRequire, TypeScriptParserIdentifier:
		{
			p.SetState(892)
			p.IdentifierOrKeyWord()
		}

	case TypeScriptParserOpenBracket:
		{
			p.SetState(893)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		{
			p.SetState(894)
			p.ObjectLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(898)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(897)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(900)
			p.singleExpression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(903)
			p.Match(TypeScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(904)
				p.TypeParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(907)
			p.singleExpression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, TypeScriptParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Match(TypeScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext
	SemiColon() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, TypeScriptParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(912)

	if !(p.NotOpenBraceAndNotFunction()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.NotOpenBraceAndNotFunction()", ""))
		goto errorExit
	}
	{
		p.SetState(913)
		p.ExpressionSequence()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(914)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Else() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *IfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, TypeScriptParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.Match(TypeScriptParserIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(918)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(919)
		p.ExpressionSequence()
	}
	{
		p.SetState(920)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(921)
		p.Statement()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(922)
			p.Match(TypeScriptParserElse)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iterationStatement
	return p
}

func InitEmptyIterationStatementContext(p *IterationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iterationStatement
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyAll(ctx *IterationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForVarStatementContext struct {
	IterationStatementContext
}

func NewForVarStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarStatementContext {
	var p = new(ForVarStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForVarStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForVarStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *ForVarStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *ForVarStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *ForVarStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForVarStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			len++
		}
	}

	tst := make([]IExpressionSequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionSequenceContext); ok {
			tst[i] = t.(IExpressionSequenceContext)
			i++
		}
	}

	return tst
}

func (s *ForVarStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForVarStatement(s)
	}
}

func (s *ForVarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForVarStatement(s)
	}
}

func (s *ForVarStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitForVarStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForVarInStatementContext struct {
	IterationStatementContext
}

func NewForVarInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarInStatementContext {
	var p = new(ForVarInStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForVarInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForVarInStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarInStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForVarInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForVarInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *ForVarInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ForVarInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForVarInStatement(s)
	}
}

func (s *ForVarInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForVarInStatement(s)
	}
}

func (s *ForVarInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitForVarInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStatementContext struct {
	IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStatementContext struct {
	IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			len++
		}
	}

	tst := make([]IExpressionSequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionSequenceContext); ok {
			tst[i] = t.(IExpressionSequenceContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForInStatementContext struct {
	IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForInStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *ForInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, TypeScriptParserRULE_iterationStatement)
	var _la int

	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(926)
			p.Match(TypeScriptParserDo)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(927)
			p.Statement()
		}
		{
			p.SetState(928)
			p.Match(TypeScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(929)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.ExpressionSequence()
		}
		{
			p.SetState(931)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(932)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(934)
			p.Match(TypeScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(935)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.ExpressionSequence()
		}
		{
			p.SetState(937)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(938)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(940)
			p.Match(TypeScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(941)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928706728) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
			{
				p.SetState(942)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(945)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928706728) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
			{
				p.SetState(946)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(949)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928706728) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
			{
				p.SetState(950)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(953)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(954)
			p.Statement()
		}

	case 4:
		localctx = NewForVarStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(955)
			p.Match(TypeScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(956)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(957)
			p.VarModifier()
		}
		{
			p.SetState(958)
			p.VariableDeclarationList()
		}
		{
			p.SetState(959)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928706728) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
			{
				p.SetState(960)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(963)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928706728) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
			{
				p.SetState(964)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(967)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.Statement()
		}

	case 5:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(970)
			p.Match(TypeScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(971)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(972)
			p.singleExpression(0)
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserIn:
			{
				p.SetState(973)
				p.Match(TypeScriptParserIn)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TypeScriptParserIdentifier:
			{
				p.SetState(974)
				p.Match(TypeScriptParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(975)

			if !(p.P("of")) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.P(\"of\")", ""))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(978)
			p.ExpressionSequence()
		}
		{
			p.SetState(979)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(980)
			p.Statement()
		}

	case 6:
		localctx = NewForVarInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(982)
			p.Match(TypeScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(984)
			p.VarModifier()
		}
		{
			p.SetState(985)
			p.VariableDeclaration()
		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserIn:
			{
				p.SetState(986)
				p.Match(TypeScriptParserIn)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TypeScriptParserIdentifier:
			{
				p.SetState(987)
				p.Match(TypeScriptParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(988)

			if !(p.P("of")) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.P(\"of\")", ""))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(991)
			p.ExpressionSequence()
		}
		{
			p.SetState(992)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(993)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Var() antlr.TerminalNode
	Let() antlr.TerminalNode
	Const() antlr.TerminalNode

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_varModifier
	return p
}

func InitEmptyVarModifierContext(p *VarModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_varModifier
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVar, 0)
}

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (s *VarModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitVarModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) VarModifier() (localctx IVarModifierContext) {
	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, TypeScriptParserRULE_varModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&2281701377) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Continue() antlr.TerminalNode
	Eos() IEosContext
	Identifier() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, TypeScriptParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(TypeScriptParserContinue)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		p.SetState(1000)

		if !(p.NotLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(1001)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1004)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Eos() IEosContext
	Identifier() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, TypeScriptParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(TypeScriptParserBreak)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		p.SetState(1007)

		if !(p.NotLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(1008)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1011)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Return() antlr.TerminalNode
	Eos() IEosContext
	ExpressionSequence() IExpressionSequenceContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, TypeScriptParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(TypeScriptParserReturn)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		p.SetState(1014)

		if !(p.NotLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(1015)
			p.ExpressionSequence()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1018)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Yield() antlr.TerminalNode
	Eos() IEosContext
	ExpressionSequence() IExpressionSequenceContext

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_yieldStatement
	return p
}

func InitEmptyYieldStatementContext(p *YieldStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_yieldStatement
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Yield() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserYield, 0)
}

func (s *YieldStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *YieldStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (s *YieldStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitYieldStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) YieldStatement() (localctx IYieldStatementContext) {
	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, TypeScriptParserRULE_yieldStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(TypeScriptParserYield)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		p.SetState(1021)

		if !(p.NotLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(1022)
			p.ExpressionSequence()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1025)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	With() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	Statement() IStatementContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, TypeScriptParserRULE_withStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1027)
		p.Match(TypeScriptParserWith)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1028)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1029)
		p.ExpressionSequence()
	}
	{
		p.SetState(1030)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1031)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Switch() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	CaseBlock() ICaseBlockContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, TypeScriptParserRULE_switchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.Match(TypeScriptParserSwitch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1034)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1035)
		p.ExpressionSequence()
	}
	{
		p.SetState(1036)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1037)
		p.CaseBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllCaseClauses() []ICaseClausesContext
	CaseClauses(i int) ICaseClausesContext
	DefaultClause() IDefaultClauseContext

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseBlock
	return p
}

func InitEmptyCaseBlockContext(p *CaseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseBlock
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClausesContext); ok {
			len++
		}
	}

	tst := make([]ICaseClausesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClausesContext); ok {
			tst[i] = t.(ICaseClausesContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClausesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (s *CaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, TypeScriptParserRULE_caseBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserCase {
		{
			p.SetState(1040)
			p.CaseClauses()
		}

	}
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserDefault {
		{
			p.SetState(1043)
			p.DefaultClause()
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserCase {
			{
				p.SetState(1044)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(1049)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClauses
	return p
}

func InitEmptyCaseClausesContext(p *CaseClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClauses
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (s *CaseClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCaseClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, TypeScriptParserRULE_caseClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TypeScriptParserCase {
		{
			p.SetState(1051)
			p.CaseClause()
		}

		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Case() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, TypeScriptParserRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(TypeScriptParserCase)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1057)
		p.ExpressionSequence()
	}
	{
		p.SetState(1058)
		p.Match(TypeScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1059)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Default() antlr.TerminalNode
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, TypeScriptParserRULE_defaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.Match(TypeScriptParserDefault)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1063)
		p.Match(TypeScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1064)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Colon() antlr.TerminalNode
	Statement() IStatementContext

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_labelledStatement
	return p
}

func InitEmptyLabelledStatementContext(p *LabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_labelledStatement
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) LabelledStatement() (localctx ILabelledStatementContext) {
	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, TypeScriptParserRULE_labelledStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1068)
		p.Match(TypeScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1069)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Throw() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	Eos() IEosContext

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, TypeScriptParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1071)
		p.Match(TypeScriptParserThrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1072)

	if !(p.NotLineTerminator()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
		goto errorExit
	}
	{
		p.SetState(1073)
		p.ExpressionSequence()
	}
	{
		p.SetState(1074)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Try() antlr.TerminalNode
	Block() IBlockContext
	CatchProduction() ICatchProductionContext
	FinallyProduction() IFinallyProductionContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, TypeScriptParserRULE_tryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Match(TypeScriptParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1077)
		p.Block()
	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserCatch:
		{
			p.SetState(1078)
			p.CatchProduction()
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1079)
				p.FinallyProduction()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TypeScriptParserFinally:
		{
			p.SetState(1082)
			p.FinallyProduction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Catch() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	Block() IBlockContext

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_catchProduction
	return p
}

func InitEmptyCatchProductionContext(p *CatchProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_catchProduction
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCatch, 0)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (s *CatchProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCatchProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, TypeScriptParserRULE_catchProduction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(TypeScriptParserCatch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1086)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1089)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Finally() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_finallyProduction
	return p
}

func InitEmptyFinallyProductionContext(p *FinallyProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_finallyProduction
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFinallyProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, TypeScriptParserRULE_finallyProduction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Match(TypeScriptParserFinally)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1092)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Debugger() antlr.TerminalNode
	Eos() IEosContext

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_debuggerStatement
	return p
}

func InitEmptyDebuggerStatementContext(p *DebuggerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_debuggerStatement
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDebuggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, TypeScriptParserRULE_debuggerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(TypeScriptParserDebugger)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1095)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	CallSignature() ICallSignatureContext
	SemiColon() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction_, 0)
}

func (s *FunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *FunctionDeclarationContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *FunctionDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *FunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, TypeScriptParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(TypeScriptParserFunction_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1098)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1099)
		p.CallSignature()
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserOpenBrace:
		{
			p.SetState(1100)
			p.Match(TypeScriptParserOpenBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1101)
			p.FunctionBody()
		}
		{
			p.SetState(1102)
			p.Match(TypeScriptParserCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserSemiColon:
		{
			p.SetState(1104)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ClassHeritage() IClassHeritageContext
	ClassTail() IClassTailContext
	DecoratorList() IDecoratorListContext
	Export() antlr.TerminalNode
	Abstract() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	Default() antlr.TerminalNode

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassHeritage() IClassHeritageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHeritageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHeritageContext)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *ClassDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *ClassDeclarationContext) Abstract() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAbstract, 0)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, TypeScriptParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(1107)
			p.DecoratorList()
		}

	}
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExport {
		{
			p.SetState(1110)
			p.Match(TypeScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserDefault {
			{
				p.SetState(1111)
				p.Match(TypeScriptParserDefault)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAbstract {
		{
			p.SetState(1116)
			p.Match(TypeScriptParserAbstract)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1119)
		p.Match(TypeScriptParserClass)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1120)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(1121)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1124)
		p.ClassHeritage()
	}
	{
		p.SetState(1125)
		p.ClassTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassHeritageContext is an interface to support dynamic dispatch.
type IClassHeritageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassExtendsClause() IClassExtendsClauseContext
	ImplementsClause() IImplementsClauseContext

	// IsClassHeritageContext differentiates from other interfaces.
	IsClassHeritageContext()
}

type ClassHeritageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHeritageContext() *ClassHeritageContext {
	var p = new(ClassHeritageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classHeritage
	return p
}

func InitEmptyClassHeritageContext(p *ClassHeritageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classHeritage
}

func (*ClassHeritageContext) IsClassHeritageContext() {}

func NewClassHeritageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHeritageContext {
	var p = new(ClassHeritageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classHeritage

	return p
}

func (s *ClassHeritageContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHeritageContext) ClassExtendsClause() IClassExtendsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassExtendsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassExtendsClauseContext)
}

func (s *ClassHeritageContext) ImplementsClause() IImplementsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsClauseContext)
}

func (s *ClassHeritageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHeritageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHeritageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassHeritage(s)
	}
}

func (s *ClassHeritageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassHeritage(s)
	}
}

func (s *ClassHeritageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassHeritage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassHeritage() (localctx IClassHeritageContext) {
	localctx = NewClassHeritageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, TypeScriptParserRULE_classHeritage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExtends {
		{
			p.SetState(1127)
			p.ClassExtendsClause()
		}

	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserImplements {
		{
			p.SetState(1130)
			p.ImplementsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllClassElement() []IClassElementContext
	ClassElement(i int) IClassElementContext

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classTail
	return p
}

func InitEmptyClassTailContext(p *ClassTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classTail
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassElementContext); ok {
			len++
		}
	}

	tst := make([]IClassElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassElementContext); ok {
			tst[i] = t.(IClassElementContext)
			i++
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassTail(s)
	}
}

func (s *ClassTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassTail(s)
	}
}

func (s *ClassTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassTail() (localctx IClassTailContext) {
	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, TypeScriptParserRULE_classTail)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1134)
				p.ClassElement()
			}

		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1140)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassExtendsClauseContext is an interface to support dynamic dispatch.
type IClassExtendsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Extends() antlr.TerminalNode
	TypeReference() ITypeReferenceContext

	// IsClassExtendsClauseContext differentiates from other interfaces.
	IsClassExtendsClauseContext()
}

type ClassExtendsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassExtendsClauseContext() *ClassExtendsClauseContext {
	var p = new(ClassExtendsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classExtendsClause
	return p
}

func InitEmptyClassExtendsClauseContext(p *ClassExtendsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classExtendsClause
}

func (*ClassExtendsClauseContext) IsClassExtendsClauseContext() {}

func NewClassExtendsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassExtendsClauseContext {
	var p = new(ClassExtendsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classExtendsClause

	return p
}

func (s *ClassExtendsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassExtendsClauseContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *ClassExtendsClauseContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ClassExtendsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExtendsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassExtendsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassExtendsClause(s)
	}
}

func (s *ClassExtendsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassExtendsClause(s)
	}
}

func (s *ClassExtendsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassExtendsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassExtendsClause() (localctx IClassExtendsClauseContext) {
	localctx = NewClassExtendsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, TypeScriptParserRULE_classExtendsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Match(TypeScriptParserExtends)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.TypeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementsClauseContext is an interface to support dynamic dispatch.
type IImplementsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Implements() antlr.TerminalNode
	ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext

	// IsImplementsClauseContext differentiates from other interfaces.
	IsImplementsClauseContext()
}

type ImplementsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsClauseContext() *ImplementsClauseContext {
	var p = new(ImplementsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_implementsClause
	return p
}

func InitEmptyImplementsClauseContext(p *ImplementsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_implementsClause
}

func (*ImplementsClauseContext) IsImplementsClauseContext() {}

func NewImplementsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsClauseContext {
	var p = new(ImplementsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_implementsClause

	return p
}

func (s *ImplementsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsClauseContext) Implements() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImplements, 0)
}

func (s *ImplementsClauseContext) ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeListContext)
}

func (s *ImplementsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImplementsClause(s)
	}
}

func (s *ImplementsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImplementsClause(s)
	}
}

func (s *ImplementsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitImplementsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ImplementsClause() (localctx IImplementsClauseContext) {
	localctx = NewImplementsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, TypeScriptParserRULE_implementsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(TypeScriptParserImplements)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1146)
		p.ClassOrInterfaceTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorDeclaration() IConstructorDeclarationContext
	PropertyMemberDeclaration() IPropertyMemberDeclarationContext
	DecoratorList() IDecoratorListContext
	IndexMemberDeclaration() IIndexMemberDeclarationContext
	Statement() IStatementContext

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classElement
	return p
}

func InitEmptyClassElementContext(p *ClassElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classElement
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *ClassElementContext) PropertyMemberDeclaration() IPropertyMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberDeclarationContext)
}

func (s *ClassElementContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *ClassElementContext) IndexMemberDeclaration() IIndexMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberDeclarationContext)
}

func (s *ClassElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassElement(s)
	}
}

func (s *ClassElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassElement(s)
	}
}

func (s *ClassElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitClassElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ClassElement() (localctx IClassElementContext) {
	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, TypeScriptParserRULE_classElement)
	var _la int

	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1148)
			p.ConstructorDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserAt {
			{
				p.SetState(1149)
				p.DecoratorList()
			}

		}
		{
			p.SetState(1152)
			p.PropertyMemberDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1153)
			p.IndexMemberDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1154)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyMemberDeclarationContext is an interface to support dynamic dispatch.
type IPropertyMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPropertyMemberDeclarationContext differentiates from other interfaces.
	IsPropertyMemberDeclarationContext()
}

type PropertyMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyMemberDeclarationContext() *PropertyMemberDeclarationContext {
	var p = new(PropertyMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberDeclaration
	return p
}

func InitEmptyPropertyMemberDeclarationContext(p *PropertyMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberDeclaration
}

func (*PropertyMemberDeclarationContext) IsPropertyMemberDeclarationContext() {}

func NewPropertyMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyMemberDeclarationContext {
	var p = new(PropertyMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyMemberDeclaration

	return p
}

func (s *PropertyMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyMemberDeclarationContext) CopyAll(ctx *PropertyMemberDeclarationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PropertyMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyDeclarationExpressionContext struct {
	PropertyMemberDeclarationContext
}

func NewPropertyDeclarationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyDeclarationExpressionContext {
	var p = new(PropertyDeclarationExpressionContext)

	InitEmptyPropertyMemberDeclarationContext(&p.PropertyMemberDeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyMemberDeclarationContext))

	return p
}

func (s *PropertyDeclarationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationExpressionContext) PropertyMemberBase() IPropertyMemberBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberBaseContext)
}

func (s *PropertyDeclarationExpressionContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyDeclarationExpressionContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *PropertyDeclarationExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *PropertyDeclarationExpressionContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *PropertyDeclarationExpressionContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *PropertyDeclarationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyDeclarationExpression(s)
	}
}

func (s *PropertyDeclarationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyDeclarationExpression(s)
	}
}

func (s *PropertyDeclarationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyDeclarationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MethodDeclarationExpressionContext struct {
	PropertyMemberDeclarationContext
}

func NewMethodDeclarationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodDeclarationExpressionContext {
	var p = new(MethodDeclarationExpressionContext)

	InitEmptyPropertyMemberDeclarationContext(&p.PropertyMemberDeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyMemberDeclarationContext))

	return p
}

func (s *MethodDeclarationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationExpressionContext) PropertyMemberBase() IPropertyMemberBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberBaseContext)
}

func (s *MethodDeclarationExpressionContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodDeclarationExpressionContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *MethodDeclarationExpressionContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *MethodDeclarationExpressionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *MethodDeclarationExpressionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *MethodDeclarationExpressionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *MethodDeclarationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMethodDeclarationExpression(s)
	}
}

func (s *MethodDeclarationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMethodDeclarationExpression(s)
	}
}

func (s *MethodDeclarationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMethodDeclarationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type GetterSetterDeclarationExpressionContext struct {
	PropertyMemberDeclarationContext
}

func NewGetterSetterDeclarationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetterSetterDeclarationExpressionContext {
	var p = new(GetterSetterDeclarationExpressionContext)

	InitEmptyPropertyMemberDeclarationContext(&p.PropertyMemberDeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyMemberDeclarationContext))

	return p
}

func (s *GetterSetterDeclarationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterSetterDeclarationExpressionContext) PropertyMemberBase() IPropertyMemberBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberBaseContext)
}

func (s *GetterSetterDeclarationExpressionContext) GetAccessor() IGetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetAccessorContext)
}

func (s *GetterSetterDeclarationExpressionContext) SetAccessor() ISetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAccessorContext)
}

func (s *GetterSetterDeclarationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGetterSetterDeclarationExpression(s)
	}
}

func (s *GetterSetterDeclarationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGetterSetterDeclarationExpression(s)
	}
}

func (s *GetterSetterDeclarationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGetterSetterDeclarationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AbstractMemberDeclarationContext struct {
	PropertyMemberDeclarationContext
}

func NewAbstractMemberDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AbstractMemberDeclarationContext {
	var p = new(AbstractMemberDeclarationContext)

	InitEmptyPropertyMemberDeclarationContext(&p.PropertyMemberDeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyMemberDeclarationContext))

	return p
}

func (s *AbstractMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractMemberDeclarationContext) AbstractDeclaration() IAbstractDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclarationContext)
}

func (s *AbstractMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAbstractMemberDeclaration(s)
	}
}

func (s *AbstractMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAbstractMemberDeclaration(s)
	}
}

func (s *AbstractMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAbstractMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PropertyMemberDeclaration() (localctx IPropertyMemberDeclarationContext) {
	localctx = NewPropertyMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, TypeScriptParserRULE_propertyMemberDeclaration)
	var _la int

	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyDeclarationExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1157)
			p.PropertyMemberBase()
		}
		{
			p.SetState(1158)
			p.PropertyName()
		}
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserQuestionMark {
			{
				p.SetState(1159)
				p.Match(TypeScriptParserQuestionMark)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(1162)
				p.TypeAnnotation()
			}

		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserAssign {
			{
				p.SetState(1165)
				p.Initializer()
			}

		}
		{
			p.SetState(1168)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewMethodDeclarationExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1170)
			p.PropertyMemberBase()
		}
		{
			p.SetState(1171)
			p.PropertyName()
		}
		{
			p.SetState(1172)
			p.CallSignature()
		}
		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserOpenBrace:
			{
				p.SetState(1173)
				p.Match(TypeScriptParserOpenBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1174)
				p.FunctionBody()
			}
			{
				p.SetState(1175)
				p.Match(TypeScriptParserCloseBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TypeScriptParserSemiColon:
			{
				p.SetState(1177)
				p.Match(TypeScriptParserSemiColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewGetterSetterDeclarationExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1180)
			p.PropertyMemberBase()
		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserGet:
			{
				p.SetState(1181)
				p.GetAccessor()
			}

		case TypeScriptParserSet:
			{
				p.SetState(1182)
				p.SetAccessor()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewAbstractMemberDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1185)
			p.AbstractDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyMemberBaseContext is an interface to support dynamic dispatch.
type IPropertyMemberBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessibilityModifier() IAccessibilityModifierContext
	Async() antlr.TerminalNode
	Static() antlr.TerminalNode
	ReadOnly() antlr.TerminalNode

	// IsPropertyMemberBaseContext differentiates from other interfaces.
	IsPropertyMemberBaseContext()
}

type PropertyMemberBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyMemberBaseContext() *PropertyMemberBaseContext {
	var p = new(PropertyMemberBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberBase
	return p
}

func InitEmptyPropertyMemberBaseContext(p *PropertyMemberBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberBase
}

func (*PropertyMemberBaseContext) IsPropertyMemberBaseContext() {}

func NewPropertyMemberBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyMemberBaseContext {
	var p = new(PropertyMemberBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyMemberBase

	return p
}

func (s *PropertyMemberBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyMemberBaseContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *PropertyMemberBaseContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *PropertyMemberBaseContext) Static() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStatic, 0)
}

func (s *PropertyMemberBaseContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *PropertyMemberBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyMemberBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyMemberBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyMemberBase(s)
	}
}

func (s *PropertyMemberBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyMemberBase(s)
	}
}

func (s *PropertyMemberBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyMemberBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PropertyMemberBase() (localctx IPropertyMemberBaseContext) {
	localctx = NewPropertyMemberBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, TypeScriptParserRULE_propertyMemberBase)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1188)
			p.AccessibilityModifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1191)
			p.Match(TypeScriptParserAsync)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1194)
			p.Match(TypeScriptParserStatic)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1197)
			p.Match(TypeScriptParserReadOnly)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexMemberDeclarationContext is an interface to support dynamic dispatch.
type IIndexMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexSignature() IIndexSignatureContext
	SemiColon() antlr.TerminalNode

	// IsIndexMemberDeclarationContext differentiates from other interfaces.
	IsIndexMemberDeclarationContext()
}

type IndexMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexMemberDeclarationContext() *IndexMemberDeclarationContext {
	var p = new(IndexMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexMemberDeclaration
	return p
}

func InitEmptyIndexMemberDeclarationContext(p *IndexMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexMemberDeclaration
}

func (*IndexMemberDeclarationContext) IsIndexMemberDeclarationContext() {}

func NewIndexMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexMemberDeclarationContext {
	var p = new(IndexMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_indexMemberDeclaration

	return p
}

func (s *IndexMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexMemberDeclarationContext) IndexSignature() IIndexSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexSignatureContext)
}

func (s *IndexMemberDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *IndexMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIndexMemberDeclaration(s)
	}
}

func (s *IndexMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIndexMemberDeclaration(s)
	}
}

func (s *IndexMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIndexMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IndexMemberDeclaration() (localctx IIndexMemberDeclarationContext) {
	localctx = NewIndexMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, TypeScriptParserRULE_indexMemberDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.IndexSignature()
	}
	{
		p.SetState(1201)
		p.Match(TypeScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratorMethodContext is an interface to support dynamic dispatch.
type IGeneratorMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	Multiply() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsGeneratorMethodContext differentiates from other interfaces.
	IsGeneratorMethodContext()
}

type GeneratorMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorMethodContext() *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorMethod
	return p
}

func InitEmptyGeneratorMethodContext(p *GeneratorMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorMethod
}

func (*GeneratorMethodContext) IsGeneratorMethodContext() {}

func NewGeneratorMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorMethod

	return p
}

func (s *GeneratorMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorMethodContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *GeneratorMethodContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GeneratorMethodContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GeneratorMethodContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorMethodContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GeneratorMethodContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorMethodContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorMethodContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *GeneratorMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorMethod(s)
	}
}

func (s *GeneratorMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorMethod(s)
	}
}

func (s *GeneratorMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) GeneratorMethod() (localctx IGeneratorMethodContext) {
	localctx = NewGeneratorMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, TypeScriptParserRULE_generatorMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserMultiply {
		{
			p.SetState(1203)
			p.Match(TypeScriptParserMultiply)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1206)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1207)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
		{
			p.SetState(1208)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1211)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1212)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1213)
		p.FunctionBody()
	}
	{
		p.SetState(1214)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratorFunctionDeclarationContext is an interface to support dynamic dispatch.
type IGeneratorFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_() antlr.TerminalNode
	Multiply() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsGeneratorFunctionDeclarationContext differentiates from other interfaces.
	IsGeneratorFunctionDeclarationContext()
}

type GeneratorFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorFunctionDeclarationContext() *GeneratorFunctionDeclarationContext {
	var p = new(GeneratorFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorFunctionDeclaration
	return p
}

func InitEmptyGeneratorFunctionDeclarationContext(p *GeneratorFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorFunctionDeclaration
}

func (*GeneratorFunctionDeclarationContext) IsGeneratorFunctionDeclarationContext() {}

func NewGeneratorFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorFunctionDeclarationContext {
	var p = new(GeneratorFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorFunctionDeclaration

	return p
}

func (s *GeneratorFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorFunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction_, 0)
}

func (s *GeneratorFunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorFunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GeneratorFunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GeneratorFunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorFunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GeneratorFunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorFunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *GeneratorFunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *GeneratorFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorFunctionDeclaration(s)
	}
}

func (s *GeneratorFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorFunctionDeclaration(s)
	}
}

func (s *GeneratorFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) GeneratorFunctionDeclaration() (localctx IGeneratorFunctionDeclarationContext) {
	localctx = NewGeneratorFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, TypeScriptParserRULE_generatorFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1216)
		p.Match(TypeScriptParserFunction_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1217)
		p.Match(TypeScriptParserMultiply)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserIdentifier {
		{
			p.SetState(1218)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1221)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
		{
			p.SetState(1222)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1225)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1226)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1227)
		p.FunctionBody()
	}
	{
		p.SetState(1228)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratorBlockContext is an interface to support dynamic dispatch.
type IGeneratorBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	AllGeneratorDefinition() []IGeneratorDefinitionContext
	GeneratorDefinition(i int) IGeneratorDefinitionContext
	CloseBrace() antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsGeneratorBlockContext differentiates from other interfaces.
	IsGeneratorBlockContext()
}

type GeneratorBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorBlockContext() *GeneratorBlockContext {
	var p = new(GeneratorBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorBlock
	return p
}

func InitEmptyGeneratorBlockContext(p *GeneratorBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorBlock
}

func (*GeneratorBlockContext) IsGeneratorBlockContext() {}

func NewGeneratorBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorBlockContext {
	var p = new(GeneratorBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorBlock

	return p
}

func (s *GeneratorBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorBlockContext) AllGeneratorDefinition() []IGeneratorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGeneratorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IGeneratorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGeneratorDefinitionContext); ok {
			tst[i] = t.(IGeneratorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *GeneratorBlockContext) GeneratorDefinition(i int) IGeneratorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorDefinitionContext)
}

func (s *GeneratorBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorBlockContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *GeneratorBlockContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *GeneratorBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorBlock(s)
	}
}

func (s *GeneratorBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorBlock(s)
	}
}

func (s *GeneratorBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) GeneratorBlock() (localctx IGeneratorBlockContext) {
	localctx = NewGeneratorBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, TypeScriptParserRULE_generatorBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1231)
		p.GeneratorDefinition()
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1232)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1233)
				p.GeneratorDefinition()
			}

		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(1239)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1242)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratorDefinitionContext is an interface to support dynamic dispatch.
type IGeneratorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Multiply() antlr.TerminalNode
	IteratorDefinition() IIteratorDefinitionContext

	// IsGeneratorDefinitionContext differentiates from other interfaces.
	IsGeneratorDefinitionContext()
}

type GeneratorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorDefinitionContext() *GeneratorDefinitionContext {
	var p = new(GeneratorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorDefinition
	return p
}

func InitEmptyGeneratorDefinitionContext(p *GeneratorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorDefinition
}

func (*GeneratorDefinitionContext) IsGeneratorDefinitionContext() {}

func NewGeneratorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorDefinitionContext {
	var p = new(GeneratorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorDefinition

	return p
}

func (s *GeneratorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorDefinitionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorDefinitionContext) IteratorDefinition() IIteratorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorDefinitionContext)
}

func (s *GeneratorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorDefinition(s)
	}
}

func (s *GeneratorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorDefinition(s)
	}
}

func (s *GeneratorDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) GeneratorDefinition() (localctx IGeneratorDefinitionContext) {
	localctx = NewGeneratorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, TypeScriptParserRULE_generatorDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1244)
		p.Match(TypeScriptParserMultiply)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1245)
		p.IteratorDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIteratorBlockContext is an interface to support dynamic dispatch.
type IIteratorBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	AllIteratorDefinition() []IIteratorDefinitionContext
	IteratorDefinition(i int) IIteratorDefinitionContext
	CloseBrace() antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsIteratorBlockContext differentiates from other interfaces.
	IsIteratorBlockContext()
}

type IteratorBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorBlockContext() *IteratorBlockContext {
	var p = new(IteratorBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorBlock
	return p
}

func InitEmptyIteratorBlockContext(p *IteratorBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorBlock
}

func (*IteratorBlockContext) IsIteratorBlockContext() {}

func NewIteratorBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorBlockContext {
	var p = new(IteratorBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iteratorBlock

	return p
}

func (s *IteratorBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *IteratorBlockContext) AllIteratorDefinition() []IIteratorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IIteratorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIteratorDefinitionContext); ok {
			tst[i] = t.(IIteratorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *IteratorBlockContext) IteratorDefinition(i int) IIteratorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorDefinitionContext)
}

func (s *IteratorBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *IteratorBlockContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *IteratorBlockContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *IteratorBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorBlock(s)
	}
}

func (s *IteratorBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorBlock(s)
	}
}

func (s *IteratorBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIteratorBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IteratorBlock() (localctx IIteratorBlockContext) {
	localctx = NewIteratorBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, TypeScriptParserRULE_iteratorBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.IteratorDefinition()
	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1249)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1250)
				p.IteratorDefinition()
			}

		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(1256)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1259)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIteratorDefinitionContext is an interface to support dynamic dispatch.
type IIteratorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseBracket() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsIteratorDefinitionContext differentiates from other interfaces.
	IsIteratorDefinitionContext()
}

type IteratorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorDefinitionContext() *IteratorDefinitionContext {
	var p = new(IteratorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorDefinition
	return p
}

func InitEmptyIteratorDefinitionContext(p *IteratorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorDefinition
}

func (*IteratorDefinitionContext) IsIteratorDefinitionContext() {}

func NewIteratorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorDefinitionContext {
	var p = new(IteratorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iteratorDefinition

	return p
}

func (s *IteratorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorDefinitionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *IteratorDefinitionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *IteratorDefinitionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *IteratorDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *IteratorDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *IteratorDefinitionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *IteratorDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *IteratorDefinitionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *IteratorDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *IteratorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorDefinition(s)
	}
}

func (s *IteratorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorDefinition(s)
	}
}

func (s *IteratorDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIteratorDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IteratorDefinition() (localctx IIteratorDefinitionContext) {
	localctx = NewIteratorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, TypeScriptParserRULE_iteratorDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1261)
		p.Match(TypeScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1262)
		p.singleExpression(0)
	}
	{
		p.SetState(1263)
		p.Match(TypeScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1264)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
		{
			p.SetState(1265)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1268)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1269)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1270)
		p.FunctionBody()
	}
	{
		p.SetState(1271)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameterArg() []IFormalParameterArgContext
	FormalParameterArg(i int) IFormalParameterArgContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	LastFormalParameterArg() ILastFormalParameterArgContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext
	Colon() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterArgContext); ok {
			tst[i] = t.(IFormalParameterArgContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *FormalParameterListContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *FormalParameterListContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *FormalParameterListContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, TypeScriptParserRULE_formalParameterList)
	var _la int

	var _alt int

	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserProtected, TypeScriptParserTypeAlias, TypeScriptParserRequire, TypeScriptParserAt, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1273)
			p.FormalParameterArg()
		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1274)
					p.Match(TypeScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1275)
					p.FormalParameterArg()
				}

			}
			p.SetState(1280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(1281)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1282)
				p.LastFormalParameterArg()
			}

		}

	case TypeScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1285)
			p.LastFormalParameterArg()
		}

	case TypeScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1286)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1287)
			p.ObjectLiteral()
		}
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(1288)
				p.Match(TypeScriptParserColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1289)
				p.FormalParameterList()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrKeyWord() IIdentifierOrKeyWordContext
	Decorator() IDecoratorContext
	AccessibilityModifier() IAccessibilityModifierContext
	QuestionMark() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterArg
	return p
}

func InitEmptyFormalParameterArgContext(p *FormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterArg
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) IdentifierOrKeyWord() IIdentifierOrKeyWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrKeyWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrKeyWordContext)
}

func (s *FormalParameterArgContext) Decorator() IDecoratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *FormalParameterArgContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *FormalParameterArgContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *FormalParameterArgContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, TypeScriptParserRULE_formalParameterArg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(1294)
			p.Decorator()
		}

	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&19) != 0 {
		{
			p.SetState(1297)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(1300)
		p.IdentifierOrKeyWord()
	}
	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserQuestionMark {
		{
			p.SetState(1301)
			p.Match(TypeScriptParserQuestionMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1304)
			p.TypeAnnotation()
		}

	}
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAssign {
		{
			p.SetState(1307)
			p.Match(TypeScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1308)
			p.singleExpression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ellipsis() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_lastFormalParameterArg
	return p
}

func InitEmptyLastFormalParameterArgContext(p *LastFormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_lastFormalParameterArg
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LastFormalParameterArgContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLastFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, TypeScriptParserRULE_lastFormalParameterArg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1311)
		p.Match(TypeScriptParserEllipsis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1312)
		p.Match(TypeScriptParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1313)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SourceElements() ISourceElementsContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, TypeScriptParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1316)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSourceElement() []ISourceElementContext
	SourceElement(i int) ISourceElementContext

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElements
	return p
}

func InitEmptySourceElementsContext(p *SourceElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElements
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceElementContext); ok {
			len++
		}
	}

	tst := make([]ISourceElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceElementContext); ok {
			tst[i] = t.(ISourceElementContext)
			i++
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (s *SourceElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSourceElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) SourceElements() (localctx ISourceElementsContext) {
	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, TypeScriptParserRULE_sourceElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1319)
				p.SourceElement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	CloseBracket() antlr.TerminalNode
	ElementList() IElementListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, TypeScriptParserRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1324)
		p.Match(TypeScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928641192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
		{
			p.SetState(1325)
			p.ElementList()
		}

	}
	{
		p.SetState(1328)
		p.Match(TypeScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArrayElement() []IArrayElementContext
	ArrayElement(i int) IArrayElementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllArrayElement() []IArrayElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElementContext); ok {
			len++
		}
	}

	tst := make([]IArrayElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElementContext); ok {
			tst[i] = t.(IArrayElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) ArrayElement(i int) IArrayElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElementContext)
}

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, TypeScriptParserRULE_elementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1330)
		p.ArrayElement()
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		p.SetState(1332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TypeScriptParserComma {
			{
				p.SetState(1331)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1334)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1336)
			p.ArrayElement()
		}

		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayElementContext is an interface to support dynamic dispatch.
type IArrayElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Identifier() antlr.TerminalNode
	Ellipsis() antlr.TerminalNode
	Comma() antlr.TerminalNode

	// IsArrayElementContext differentiates from other interfaces.
	IsArrayElementContext()
}

type ArrayElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElementContext() *ArrayElementContext {
	var p = new(ArrayElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayElement
	return p
}

func InitEmptyArrayElementContext(p *ArrayElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayElement
}

func (*ArrayElementContext) IsArrayElementContext() {}

func NewArrayElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElementContext {
	var p = new(ArrayElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrayElement

	return p
}

func (s *ArrayElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrayElementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ArrayElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *ArrayElementContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *ArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayElement(s)
	}
}

func (s *ArrayElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayElement(s)
	}
}

func (s *ArrayElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrayElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrayElement() (localctx IArrayElementContext) {
	localctx = NewArrayElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, TypeScriptParserRULE_arrayElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserEllipsis {
		{
			p.SetState(1342)
			p.Match(TypeScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1345)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(1346)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1349)
			p.Match(TypeScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllPropertyAssignment() []IPropertyAssignmentContext
	PropertyAssignment(i int) IPropertyAssignmentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IPropertyAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyAssignmentContext); ok {
			tst[i] = t.(IPropertyAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, TypeScriptParserRULE_objectLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1352)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028797002121200) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&3517012241796825087) != 0) {
		{
			p.SetState(1353)
			p.PropertyAssignment()
		}
		p.SetState(1358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1354)
					p.Match(TypeScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1355)
					p.PropertyAssignment()
				}

			}
			p.SetState(1360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(1361)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1366)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyAssignment
	return p
}

func InitEmptyPropertyAssignmentContext(p *PropertyAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyAssignment
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyAll(ctx *PropertyAssignmentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitComputedPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyShorthandContext struct {
	PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) IdentifierOrKeyWord() IIdentifierOrKeyWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrKeyWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrKeyWordContext)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertySetterContext struct {
	PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) SetAccessor() ISetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAccessorContext)
}

func (s *PropertySetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertySetter(s)
	}
}

func (s *PropertySetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertySetter(s)
	}
}

func (s *PropertySetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertySetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyGetterContext struct {
	PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) GetAccessor() IGetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetAccessorContext)
}

func (s *PropertyGetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type RestParameterInObjectContext struct {
	PropertyAssignmentContext
}

func NewRestParameterInObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RestParameterInObjectContext {
	var p = new(RestParameterInObjectContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *RestParameterInObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestParameterInObjectContext) RestParameter() IRestParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestParameterContext)
}

func (s *RestParameterInObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRestParameterInObject(s)
	}
}

func (s *RestParameterInObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRestParameterInObject(s)
	}
}

func (s *RestParameterInObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRestParameterInObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type MethodPropertyContext struct {
	PropertyAssignmentContext
}

func NewMethodPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodPropertyContext {
	var p = new(MethodPropertyContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *MethodPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodPropertyContext) GeneratorMethod() IGeneratorMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorMethodContext)
}

func (s *MethodPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMethodProperty(s)
	}
}

func (s *MethodPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMethodProperty(s)
	}
}

func (s *MethodPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMethodProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, TypeScriptParserRULE_propertyAssignment)
	var _la int

	p.SetState(1383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1368)
			p.PropertyName()
		}
		{
			p.SetState(1369)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TypeScriptParserAssign || _la == TypeScriptParserColon) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1370)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1372)
			p.Match(TypeScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.singleExpression(0)
		}
		{
			p.SetState(1374)
			p.Match(TypeScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1375)
			p.Match(TypeScriptParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1378)
			p.GetAccessor()
		}

	case 4:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1379)
			p.SetAccessor()
		}

	case 5:
		localctx = NewMethodPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1380)
			p.GeneratorMethod()
		}

	case 6:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1381)
			p.IdentifierOrKeyWord()
		}

	case 7:
		localctx = NewRestParameterInObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1382)
			p.RestParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetAccessorContext is an interface to support dynamic dispatch.
type IGetAccessorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Getter() IGetterContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsGetAccessorContext differentiates from other interfaces.
	IsGetAccessorContext()
}

type GetAccessorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetAccessorContext() *GetAccessorContext {
	var p = new(GetAccessorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getAccessor
	return p
}

func InitEmptyGetAccessorContext(p *GetAccessorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getAccessor
}

func (*GetAccessorContext) IsGetAccessorContext() {}

func NewGetAccessorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetAccessorContext {
	var p = new(GetAccessorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_getAccessor

	return p
}

func (s *GetAccessorContext) GetParser() antlr.Parser { return s.parser }

func (s *GetAccessorContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *GetAccessorContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GetAccessorContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GetAccessorContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GetAccessorContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GetAccessorContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GetAccessorContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *GetAccessorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetAccessorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetAccessorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGetAccessor(s)
	}
}

func (s *GetAccessorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGetAccessor(s)
	}
}

func (s *GetAccessorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGetAccessor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) GetAccessor() (localctx IGetAccessorContext) {
	localctx = NewGetAccessorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, TypeScriptParserRULE_getAccessor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Getter()
	}
	{
		p.SetState(1386)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1388)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1391)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1392)
		p.FunctionBody()
	}
	{
		p.SetState(1393)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetAccessorContext is an interface to support dynamic dispatch.
type ISetAccessorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Setter() ISetterContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	BindingPattern() IBindingPatternContext
	TypeAnnotation() ITypeAnnotationContext

	// IsSetAccessorContext differentiates from other interfaces.
	IsSetAccessorContext()
}

type SetAccessorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAccessorContext() *SetAccessorContext {
	var p = new(SetAccessorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setAccessor
	return p
}

func InitEmptySetAccessorContext(p *SetAccessorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setAccessor
}

func (*SetAccessorContext) IsSetAccessorContext() {}

func NewSetAccessorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAccessorContext {
	var p = new(SetAccessorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_setAccessor

	return p
}

func (s *SetAccessorContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAccessorContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *SetAccessorContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *SetAccessorContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *SetAccessorContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *SetAccessorContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetAccessorContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *SetAccessorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *SetAccessorContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *SetAccessorContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *SetAccessorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAccessorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAccessorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSetAccessor(s)
	}
}

func (s *SetAccessorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSetAccessor(s)
	}
}

func (s *SetAccessorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSetAccessor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) SetAccessor() (localctx ISetAccessorContext) {
	localctx = NewSetAccessorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, TypeScriptParserRULE_setAccessor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1395)
		p.Setter()
	}
	{
		p.SetState(1396)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		{
			p.SetState(1397)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace:
		{
			p.SetState(1398)
			p.BindingPattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1401)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1404)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1405)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1406)
		p.FunctionBody()
	}
	{
		p.SetState(1407)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	StringLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyName
	return p
}

func InitEmptyPropertyNameContext(p *PropertyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyName
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (s *PropertyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPropertyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, TypeScriptParserRULE_propertyName)
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1409)
			p.IdentifierName()
		}

	case TypeScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1410)
			p.Match(TypeScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1411)
			p.NumericLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	Comma() antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ArgumentsContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, TypeScriptParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1414)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-36028795928641192) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8128698260224212991) != 0) {
		{
			p.SetState(1415)
			p.ArgumentList()
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(1416)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1421)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, TypeScriptParserRULE_argumentList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.Argument()
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1424)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1425)
				p.Argument()
			}

		}
		p.SetState(1430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Identifier() antlr.TerminalNode
	Ellipsis() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, TypeScriptParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserEllipsis {
		{
			p.SetState(1431)
			p.Match(TypeScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1434)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(1435)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleExpression() []ISingleExpressionContext
	SingleExpression(i int) ISingleExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionSequence
	return p
}

func InitEmptyExpressionSequenceContext(p *ExpressionSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionSequence
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitExpressionSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, TypeScriptParserRULE_expressionSequence)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1438)
		p.singleExpression(0)
	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1439)
				p.Match(TypeScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1440)
				p.singleExpression(0)
			}

		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionExpressionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionExpressionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFunctionExpressionDeclarationContext differentiates from other interfaces.
	IsFunctionExpressionDeclarationContext()
}

type FunctionExpressionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionExpressionDeclarationContext() *FunctionExpressionDeclarationContext {
	var p = new(FunctionExpressionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionExpressionDeclaration
	return p
}

func InitEmptyFunctionExpressionDeclarationContext(p *FunctionExpressionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionExpressionDeclaration
}

func (*FunctionExpressionDeclarationContext) IsFunctionExpressionDeclarationContext() {}

func NewFunctionExpressionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionExpressionDeclarationContext {
	var p = new(FunctionExpressionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionExpressionDeclaration

	return p
}

func (s *FunctionExpressionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionExpressionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction_, 0)
}

func (s *FunctionExpressionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *FunctionExpressionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *FunctionExpressionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *FunctionExpressionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionExpressionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *FunctionExpressionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *FunctionExpressionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionExpressionDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FunctionExpressionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionExpressionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionExpressionDeclaration(s)
	}
}

func (s *FunctionExpressionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionExpressionDeclaration(s)
	}
}

func (s *FunctionExpressionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFunctionExpressionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) FunctionExpressionDeclaration() (localctx IFunctionExpressionDeclarationContext) {
	localctx = NewFunctionExpressionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, TypeScriptParserRULE_functionExpressionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1446)
		p.Match(TypeScriptParserFunction_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserIdentifier {
		{
			p.SetState(1447)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1450)
		p.Match(TypeScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
		{
			p.SetState(1451)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1454)
		p.Match(TypeScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1455)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1458)
		p.Match(TypeScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1459)
		p.FunctionBody()
	}
	{
		p.SetState(1460)
		p.Match(TypeScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_singleExpression
	return p
}

func InitEmptySingleExpressionContext(p *SingleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_singleExpression
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyAll(ctx *SingleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTemplateStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExpressionContext struct {
	SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAnd, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type GeneratorsExpressionContext struct {
	SingleExpressionContext
}

func NewGeneratorsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratorsExpressionContext {
	var p = new(GeneratorsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *GeneratorsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorsExpressionContext) GeneratorBlock() IGeneratorBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorBlockContext)
}

func (s *GeneratorsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorsExpression(s)
	}
}

func (s *GeneratorsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorsExpression(s)
	}
}

func (s *GeneratorsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPreIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitObjectLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExpressionContext struct {
	SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

func (s *InExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitInExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOr, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type GenericTypesContext struct {
	SingleExpressionContext
}

func NewGenericTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericTypesContext {
	var p = new(GenericTypesContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *GenericTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypesContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *GenericTypesContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *GenericTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGenericTypes(s)
	}
}

func (s *GenericTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGenericTypes(s)
	}
}

func (s *GenericTypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGenericTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPreDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArgumentsExpressionContext struct {
	SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisExpressionContext struct {
	SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionExpressionContext struct {
	SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) FunctionExpressionDeclaration() IFunctionExpressionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionExpressionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionExpressionDeclarationContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitUnaryMinusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPostDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeofExpressionContext struct {
	SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTypeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceofExpressionContext struct {
	SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitInstanceofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitUnaryPlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteExpressionContext struct {
	SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type GeneratorsFunctionExpressionContext struct {
	SingleExpressionContext
}

func NewGeneratorsFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratorsFunctionExpressionContext {
	var p = new(GeneratorsFunctionExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *GeneratorsFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorsFunctionExpressionContext) GeneratorFunctionDeclaration() IGeneratorFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorFunctionDeclarationContext)
}

func (s *GeneratorsFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorsFunctionExpression(s)
	}
}

func (s *GeneratorsFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorsFunctionExpression(s)
	}
}

func (s *GeneratorsFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGeneratorsFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowFunctionExpressionContext struct {
	SingleExpressionContext
}

func NewArrowFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionExpressionContext {
	var p = new(ArrowFunctionExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrowFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionExpressionContext) ArrowFunctionDeclaration() IArrowFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionDeclarationContext)
}

func (s *ArrowFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionExpression(s)
	}
}

func (s *ArrowFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionExpression(s)
	}
}

func (s *ArrowFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrowFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IteratorsExpressionContext struct {
	SingleExpressionContext
}

func NewIteratorsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IteratorsExpressionContext {
	var p = new(IteratorsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *IteratorsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorsExpressionContext) IteratorBlock() IIteratorBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorBlockContext)
}

func (s *IteratorsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorsExpression(s)
	}
}

func (s *IteratorsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorsExpression(s)
	}
}

func (s *IteratorsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIteratorsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitXOrExpressionContext struct {
	SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBitXOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastAsExpressionContext struct {
	SingleExpressionContext
}

func NewCastAsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastAsExpressionContext {
	var p = new(CastAsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *CastAsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastAsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CastAsExpressionContext) As() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAs, 0)
}

func (s *CastAsExpressionContext) AsExpression() IAsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsExpressionContext)
}

func (s *CastAsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCastAsExpression(s)
	}
}

func (s *CastAsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCastAsExpression(s)
	}
}

func (s *CastAsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitCastAsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperExpressionContext struct {
	SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSuper, 0)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (s *SuperExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSuperExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitShiftExpressionContext struct {
	SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExpressionContext struct {
	SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitPostIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type YieldExpressionContext struct {
	SingleExpressionContext
}

func NewYieldExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterYieldExpression(s)
	}
}

func (s *YieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitYieldExpression(s)
	}
}

func (s *YieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitYieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewExpressionContext struct {
	SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

func (s *NewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrayLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberDotExpressionContext struct {
	SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNot, 0)
}

func (s *MemberDotExpressionContext) NestedTypeGeneric() INestedTypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedTypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedTypeGenericContext)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMemberDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberIndexExpressionContext struct {
	SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitMemberIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierExpressionContext struct {
	SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *IdentifierExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitAndExpressionContext struct {
	SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAnd, 0)
}

func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitOrExpressionContext struct {
	SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOr, 0)
}

func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitBitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAssignmentOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type VoidExpressionContext struct {
	SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVoidExpression(s)
	}
}

func (s *VoidExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVoidExpression(s)
	}
}

func (s *VoidExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitVoidExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *TypeScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 254
	p.EnterRecursionRule(localctx, 254, TypeScriptParserRULE_singleExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1463)
			p.FunctionExpressionDeclaration()
		}

	case 2:
		localctx = NewArrowFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1464)
			p.ArrowFunctionDeclaration()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1465)
			p.Match(TypeScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.singleExpression(0)
		}
		p.SetState(1468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserLessThan {
			{
				p.SetState(1467)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1470)
			p.Arguments()
		}

	case 4:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1472)
			p.Match(TypeScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1473)
			p.singleExpression(0)
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1474)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1477)
			p.Match(TypeScriptParserDelete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.singleExpression(38)
		}

	case 6:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1479)
			p.Match(TypeScriptParserVoid)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1480)
			p.singleExpression(37)
		}

	case 7:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1481)
			p.Match(TypeScriptParserTypeof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.singleExpression(36)
		}

	case 8:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1483)
			p.Match(TypeScriptParserPlusPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.singleExpression(35)
		}

	case 9:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1485)
			p.Match(TypeScriptParserMinusMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.singleExpression(34)
		}

	case 10:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1487)
			p.Match(TypeScriptParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1488)
			p.singleExpression(33)
		}

	case 11:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1489)
			p.Match(TypeScriptParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1490)
			p.singleExpression(32)
		}

	case 12:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1491)
			p.Match(TypeScriptParserBitNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1492)
			p.singleExpression(31)
		}

	case 13:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1493)
			p.Match(TypeScriptParserNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1494)
			p.singleExpression(30)
		}

	case 14:
		localctx = NewIteratorsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1495)
			p.IteratorBlock()
		}

	case 15:
		localctx = NewGeneratorsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1496)
			p.GeneratorBlock()
		}

	case 16:
		localctx = NewGeneratorsFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1497)
			p.GeneratorFunctionDeclaration()
		}

	case 17:
		localctx = NewYieldExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1498)
			p.YieldStatement()
		}

	case 18:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1499)
			p.Match(TypeScriptParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1500)
			p.IdentifierName()
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1501)
				p.singleExpression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 20:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1504)
			p.Match(TypeScriptParserSuper)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1505)
			p.Literal()
		}

	case 22:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1506)
			p.ArrayLiteral()
		}

	case 23:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1507)
			p.ObjectLiteral()
		}

	case 24:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1508)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.ExpressionSequence()
		}
		{
			p.SetState(1510)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewGenericTypesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1512)
			p.TypeArguments()
		}
		p.SetState(1514)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1513)
				p.ExpressionSequence()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1594)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1518)

				if !(p.Precpred(p.GetParserRuleContext(), 29)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 29)", ""))
					goto errorExit
				}
				{
					p.SetState(1519)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&117440512) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1520)
					p.singleExpression(30)
				}

			case 2:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1521)

				if !(p.Precpred(p.GetParserRuleContext(), 28)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 28)", ""))
					goto errorExit
				}
				{
					p.SetState(1522)
					_la = p.GetTokenStream().LA(1)

					if !(_la == TypeScriptParserPlus || _la == TypeScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1523)
					p.singleExpression(29)
				}

			case 3:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1524)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
					goto errorExit
				}
				{
					p.SetState(1525)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&939524096) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1526)
					p.singleExpression(28)
				}

			case 4:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1527)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
					goto errorExit
				}
				{
					p.SetState(1528)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16106127360) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1529)
					p.singleExpression(27)
				}

			case 5:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1530)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
					goto errorExit
				}
				{
					p.SetState(1531)
					p.Match(TypeScriptParserInstanceof)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1532)
					p.singleExpression(26)
				}

			case 6:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1533)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(1534)
					p.Match(TypeScriptParserIn)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1535)
					p.singleExpression(25)
				}

			case 7:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1536)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1537)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&257698037760) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1538)
					p.singleExpression(24)
				}

			case 8:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1539)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1540)
					p.Match(TypeScriptParserBitAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1541)
					p.singleExpression(23)
				}

			case 9:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1542)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(1543)
					p.Match(TypeScriptParserBitXOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1544)
					p.singleExpression(22)
				}

			case 10:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1545)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(1546)
					p.Match(TypeScriptParserBitOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1547)
					p.singleExpression(21)
				}

			case 11:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1548)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(1549)
					p.Match(TypeScriptParserAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1550)
					p.singleExpression(20)
				}

			case 12:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1551)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1552)
					p.Match(TypeScriptParserOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1553)
					p.singleExpression(19)
				}

			case 13:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1554)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(1555)
					p.Match(TypeScriptParserQuestionMark)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1556)
					p.singleExpression(0)
				}
				{
					p.SetState(1557)
					p.Match(TypeScriptParserColon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1558)
					p.singleExpression(18)
				}

			case 14:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1560)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1561)
					p.Match(TypeScriptParserAssign)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1562)
					p.singleExpression(17)
				}

			case 15:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1563)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1564)
					p.AssignmentOperator()
				}
				{
					p.SetState(1565)
					p.singleExpression(16)
				}

			case 16:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1567)

				if !(p.Precpred(p.GetParserRuleContext(), 45)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 45)", ""))
					goto errorExit
				}
				{
					p.SetState(1568)
					p.Match(TypeScriptParserOpenBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1569)
					p.ExpressionSequence()
				}
				{
					p.SetState(1570)
					p.Match(TypeScriptParserCloseBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 17:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1572)

				if !(p.Precpred(p.GetParserRuleContext(), 44)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 44)", ""))
					goto errorExit
				}
				p.SetState(1574)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TypeScriptParserNot {
					{
						p.SetState(1573)
						p.Match(TypeScriptParserNot)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1576)
					p.Match(TypeScriptParserDot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1577)
					p.IdentifierName()
				}
				p.SetState(1579)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1578)
						p.NestedTypeGeneric()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 18:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1581)

				if !(p.Precpred(p.GetParserRuleContext(), 41)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 41)", ""))
					goto errorExit
				}
				{
					p.SetState(1582)
					p.Arguments()
				}

			case 19:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1583)

				if !(p.Precpred(p.GetParserRuleContext(), 40)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 40)", ""))
					goto errorExit
				}
				p.SetState(1584)

				if !(p.NotLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(1585)
					p.Match(TypeScriptParserPlusPlus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 20:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1586)

				if !(p.Precpred(p.GetParserRuleContext(), 39)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 39)", ""))
					goto errorExit
				}
				p.SetState(1587)

				if !(p.NotLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.NotLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(1588)
					p.Match(TypeScriptParserMinusMinus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 21:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1589)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1590)
					p.TemplateStringLiteral()
				}

			case 22:
				localctx = NewCastAsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1591)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1592)
					p.Match(TypeScriptParserAs)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1593)
					p.AsExpression()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsExpressionContext is an interface to support dynamic dispatch.
type IAsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredefinedType() IPredefinedTypeContext
	OpenBracket() antlr.TerminalNode
	CloseBracket() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsAsExpressionContext differentiates from other interfaces.
	IsAsExpressionContext()
}

type AsExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsExpressionContext() *AsExpressionContext {
	var p = new(AsExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_asExpression
	return p
}

func InitEmptyAsExpressionContext(p *AsExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_asExpression
}

func (*AsExpressionContext) IsAsExpressionContext() {}

func NewAsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsExpressionContext {
	var p = new(AsExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_asExpression

	return p
}

func (s *AsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsExpressionContext) PredefinedType() IPredefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedTypeContext)
}

func (s *AsExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *AsExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *AsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAsExpression(s)
	}
}

func (s *AsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAsExpression(s)
	}
}

func (s *AsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) AsExpression() (localctx IAsExpressionContext) {
	localctx = NewAsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, TypeScriptParserRULE_asExpression)
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1599)
			p.PredefinedType()
		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1600)
				p.Match(TypeScriptParserOpenBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1601)
				p.Match(TypeScriptParserCloseBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.singleExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionDeclarationContext is an interface to support dynamic dispatch.
type IArrowFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrowFunctionParameters() IArrowFunctionParametersContext
	ARROW() antlr.TerminalNode
	ArrowFunctionBody() IArrowFunctionBodyContext
	Async() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsArrowFunctionDeclarationContext differentiates from other interfaces.
	IsArrowFunctionDeclarationContext()
}

type ArrowFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionDeclarationContext() *ArrowFunctionDeclarationContext {
	var p = new(ArrowFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionDeclaration
	return p
}

func InitEmptyArrowFunctionDeclarationContext(p *ArrowFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionDeclaration
}

func (*ArrowFunctionDeclarationContext) IsArrowFunctionDeclarationContext() {}

func NewArrowFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionDeclarationContext {
	var p = new(ArrowFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionDeclaration

	return p
}

func (s *ArrowFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionDeclarationContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionDeclarationContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *ArrowFunctionDeclarationContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *ArrowFunctionDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ArrowFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionDeclaration(s)
	}
}

func (s *ArrowFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionDeclaration(s)
	}
}

func (s *ArrowFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrowFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionDeclaration() (localctx IArrowFunctionDeclarationContext) {
	localctx = NewArrowFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, TypeScriptParserRULE_arrowFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAsync {
		{
			p.SetState(1607)
			p.Match(TypeScriptParserAsync)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1610)
		p.ArrowFunctionParameters()
	}
	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1611)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1614)
		p.Match(TypeScriptParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1615)
		p.ArrowFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionParameters
	return p
}

func InitEmptyArrowFunctionParametersContext(p *ArrowFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionParameters
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrowFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, TypeScriptParserRULE_arrowFunctionParameters)
	var _la int

	p.SetState(1623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1617)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1618)
			p.Match(TypeScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&65808) != 0) || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&12718099) != 0) {
			{
				p.SetState(1619)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(1622)
			p.Match(TypeScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	OpenBrace() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	CloseBrace() antlr.TerminalNode

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionBody
	return p
}

func InitEmptyArrowFunctionBodyContext(p *ArrowFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionBody
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitArrowFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, TypeScriptParserRULE_arrowFunctionBody)
	p.SetState(1630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1625)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1626)
			p.Match(TypeScriptParserOpenBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.FunctionBody()
		}
		{
			p.SetState(1628)
			p.Match(TypeScriptParserCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiplyAssign() antlr.TerminalNode
	DivideAssign() antlr.TerminalNode
	ModulusAssign() antlr.TerminalNode
	PlusAssign() antlr.TerminalNode
	MinusAssign() antlr.TerminalNode
	LeftShiftArithmeticAssign() antlr.TerminalNode
	RightShiftArithmeticAssign() antlr.TerminalNode
	RightShiftLogicalAssign() antlr.TerminalNode
	BitAndAssign() antlr.TerminalNode
	BitXorAssign() antlr.TerminalNode
	BitOrAssign() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, TypeScriptParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1632)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18005602416459776) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	TemplateStringLiteral() ITemplateStringLiteralContext
	RegularExpressionLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, TypeScriptParserRULE_literal)
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1634)
			p.Match(TypeScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1635)
			p.Match(TypeScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1636)
			p.Match(TypeScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserBackTick:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1637)
			p.TemplateStringLiteral()
		}

	case TypeScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1638)
			p.Match(TypeScriptParserRegularExpressionLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1639)
			p.NumericLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringLiteralContext is an interface to support dynamic dispatch.
type ITemplateStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBackTick() []antlr.TerminalNode
	BackTick(i int) antlr.TerminalNode
	AllTemplateStringAtom() []ITemplateStringAtomContext
	TemplateStringAtom(i int) ITemplateStringAtomContext

	// IsTemplateStringLiteralContext differentiates from other interfaces.
	IsTemplateStringLiteralContext()
}

type TemplateStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringLiteralContext() *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_templateStringLiteral
	return p
}

func InitEmptyTemplateStringLiteralContext(p *TemplateStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_templateStringLiteral
}

func (*TemplateStringLiteralContext) IsTemplateStringLiteralContext() {}

func NewTemplateStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_templateStringLiteral

	return p
}

func (s *TemplateStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringLiteralContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserBackTick)
}

func (s *TemplateStringLiteralContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBackTick, i)
}

func (s *TemplateStringLiteralContext) AllTemplateStringAtom() []ITemplateStringAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			len++
		}
	}

	tst := make([]ITemplateStringAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITemplateStringAtomContext); ok {
			tst[i] = t.(ITemplateStringAtomContext)
			i++
		}
	}

	return tst
}

func (s *TemplateStringLiteralContext) TemplateStringAtom(i int) ITemplateStringAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringAtomContext)
}

func (s *TemplateStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTemplateStringLiteral(s)
	}
}

func (s *TemplateStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTemplateStringLiteral(s)
	}
}

func (s *TemplateStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTemplateStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TemplateStringLiteral() (localctx ITemplateStringLiteralContext) {
	localctx = NewTemplateStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, TypeScriptParserRULE_templateStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1642)
		p.Match(TypeScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&7) != 0 {
		{
			p.SetState(1643)
			p.TemplateStringAtom()
		}

		p.SetState(1648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1649)
		p.Match(TypeScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringAtomContext is an interface to support dynamic dispatch.
type ITemplateStringAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TemplateStringAtom() antlr.TerminalNode
	TemplateStringStartExpression() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	TemplateCloseBrace() antlr.TerminalNode
	TemplateStringEscapeAtom() antlr.TerminalNode

	// IsTemplateStringAtomContext differentiates from other interfaces.
	IsTemplateStringAtomContext()
}

type TemplateStringAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringAtomContext() *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_templateStringAtom
	return p
}

func InitEmptyTemplateStringAtomContext(p *TemplateStringAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_templateStringAtom
}

func (*TemplateStringAtomContext) IsTemplateStringAtomContext() {}

func NewTemplateStringAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_templateStringAtom

	return p
}

func (s *TemplateStringAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringAtomContext) TemplateStringAtom() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateStringAtom, 0)
}

func (s *TemplateStringAtomContext) TemplateStringStartExpression() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateStringStartExpression, 0)
}

func (s *TemplateStringAtomContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringAtomContext) TemplateCloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateCloseBrace, 0)
}

func (s *TemplateStringAtomContext) TemplateStringEscapeAtom() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateStringEscapeAtom, 0)
}

func (s *TemplateStringAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTemplateStringAtom(s)
	}
}

func (s *TemplateStringAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTemplateStringAtom(s)
	}
}

func (s *TemplateStringAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitTemplateStringAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) TemplateStringAtom() (localctx ITemplateStringAtomContext) {
	localctx = NewTemplateStringAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, TypeScriptParserRULE_templateStringAtom)
	p.SetState(1657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserTemplateStringAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1651)
			p.Match(TypeScriptParserTemplateStringAtom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserTemplateStringStartExpression:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1652)
			p.Match(TypeScriptParserTemplateStringStartExpression)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1653)
			p.singleExpression(0)
		}
		{
			p.SetState(1654)
			p.Match(TypeScriptParserTemplateCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserTemplateStringEscapeAtom:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1656)
			p.Match(TypeScriptParserTemplateStringEscapeAtom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() antlr.TerminalNode
	HexIntegerLiteral() antlr.TerminalNode
	OctalIntegerLiteral() antlr.TerminalNode
	OctalIntegerLiteral2() antlr.TerminalNode
	BinaryIntegerLiteral() antlr.TerminalNode

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_numericLiteral
	return p
}

func InitEmptyNumericLiteralContext(p *NumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_numericLiteral
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, TypeScriptParserRULE_numericLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4467570830351532032) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ReservedWord() IReservedWordContext

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierName
	return p
}

func InitEmptyIdentifierNameContext(p *IdentifierNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierName
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (s *IdentifierNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIdentifierName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, TypeScriptParserRULE_identifierName)
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1661)
			p.Match(TypeScriptParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1662)
			p.ReservedWord()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrKeyWordContext is an interface to support dynamic dispatch.
type IIdentifierOrKeyWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	TypeAlias() antlr.TerminalNode
	Require() antlr.TerminalNode

	// IsIdentifierOrKeyWordContext differentiates from other interfaces.
	IsIdentifierOrKeyWordContext()
}

type IdentifierOrKeyWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrKeyWordContext() *IdentifierOrKeyWordContext {
	var p = new(IdentifierOrKeyWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierOrKeyWord
	return p
}

func InitEmptyIdentifierOrKeyWordContext(p *IdentifierOrKeyWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierOrKeyWord
}

func (*IdentifierOrKeyWordContext) IsIdentifierOrKeyWordContext() {}

func NewIdentifierOrKeyWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrKeyWordContext {
	var p = new(IdentifierOrKeyWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_identifierOrKeyWord

	return p
}

func (s *IdentifierOrKeyWordContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrKeyWordContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *IdentifierOrKeyWordContext) TypeAlias() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeAlias, 0)
}

func (s *IdentifierOrKeyWordContext) Require() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRequire, 0)
}

func (s *IdentifierOrKeyWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrKeyWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrKeyWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierOrKeyWord(s)
	}
}

func (s *IdentifierOrKeyWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierOrKeyWord(s)
	}
}

func (s *IdentifierOrKeyWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitIdentifierOrKeyWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) IdentifierOrKeyWord() (localctx IIdentifierOrKeyWordContext) {
	localctx = NewIdentifierOrKeyWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, TypeScriptParserRULE_identifierOrKeyWord)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&2081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword() IKeywordContext
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_reservedWord
	return p
}

func InitEmptyReservedWordContext(p *ReservedWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_reservedWord
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, TypeScriptParserRULE_reservedWord)
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction_, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserNumber, TypeScriptParserBoolean, TypeScriptParserString_, TypeScriptParserTypeAlias, TypeScriptParserGet, TypeScriptParserSet, TypeScriptParserRequire, TypeScriptParserModule:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1667)
			p.Keyword()
		}

	case TypeScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1668)
			p.Match(TypeScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TypeScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1669)
			p.Match(TypeScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Do() antlr.TerminalNode
	Instanceof() antlr.TerminalNode
	Typeof() antlr.TerminalNode
	Case() antlr.TerminalNode
	Else() antlr.TerminalNode
	New() antlr.TerminalNode
	Var() antlr.TerminalNode
	Catch() antlr.TerminalNode
	Finally() antlr.TerminalNode
	Return() antlr.TerminalNode
	Void() antlr.TerminalNode
	Continue() antlr.TerminalNode
	For() antlr.TerminalNode
	Switch() antlr.TerminalNode
	While() antlr.TerminalNode
	Debugger() antlr.TerminalNode
	Function_() antlr.TerminalNode
	This() antlr.TerminalNode
	With() antlr.TerminalNode
	Default() antlr.TerminalNode
	If() antlr.TerminalNode
	Throw() antlr.TerminalNode
	Delete() antlr.TerminalNode
	In() antlr.TerminalNode
	Try() antlr.TerminalNode
	ReadOnly() antlr.TerminalNode
	Async() antlr.TerminalNode
	From() antlr.TerminalNode
	Class() antlr.TerminalNode
	Enum() antlr.TerminalNode
	Extends() antlr.TerminalNode
	Super() antlr.TerminalNode
	Const() antlr.TerminalNode
	Export() antlr.TerminalNode
	Import() antlr.TerminalNode
	Implements() antlr.TerminalNode
	Let() antlr.TerminalNode
	Private() antlr.TerminalNode
	Public() antlr.TerminalNode
	Interface() antlr.TerminalNode
	Package() antlr.TerminalNode
	Protected() antlr.TerminalNode
	Static() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Get() antlr.TerminalNode
	Set() antlr.TerminalNode
	Require() antlr.TerminalNode
	TypeAlias() antlr.TerminalNode
	String_() antlr.TerminalNode
	Boolean() antlr.TerminalNode
	Number() antlr.TerminalNode
	Module() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDebugger, 0)
}

func (s *KeywordContext) Function_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction_, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTry, 0)
}

func (s *KeywordContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFrom, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserYield, 0)
}

func (s *KeywordContext) Get() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserGet, 0)
}

func (s *KeywordContext) Set() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSet, 0)
}

func (s *KeywordContext) Require() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRequire, 0)
}

func (s *KeywordContext) TypeAlias() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeAlias, 0)
}

func (s *KeywordContext) String_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserString_, 0)
}

func (s *KeywordContext) Boolean() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBoolean, 0)
}

func (s *KeywordContext) Number() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNumber, 0)
}

func (s *KeywordContext) Module() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserModule, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, TypeScriptParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1672)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&232990911905136639) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Get() antlr.TerminalNode
	PropertyName() IPropertyNameContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getter
	return p
}

func InitEmptyGetterContext(p *GetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getter
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Get() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserGet, 0)
}

func (s *GetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, TypeScriptParserRULE_getter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1674)
		p.Match(TypeScriptParserGet)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1675)
		p.PropertyName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set() antlr.TerminalNode
	PropertyName() IPropertyNameContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setter
	return p
}

func InitEmptySetterContext(p *SetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setter
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Set() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSet, 0)
}

func (s *SetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, TypeScriptParserRULE_setter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Match(TypeScriptParserSet)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1678)
		p.PropertyName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode
	EOF() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TypeScriptParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TypeScriptParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TypeScriptParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, TypeScriptParserRULE_eos)
	p.SetState(1684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1680)
			p.Match(TypeScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1681)
			p.Match(TypeScriptParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1682)

		if !(p.LineTerminatorAhead()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.LineTerminatorAhead()", ""))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1683)

		if !(p.CloseBrace()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.CloseBrace()", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *TypeScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 10:
		var t *UnionOrIntersectionOrPrimaryTypeContext = nil
		if localctx != nil {
			t = localctx.(*UnionOrIntersectionOrPrimaryTypeContext)
		}
		return p.UnionOrIntersectionOrPrimaryType_Sempred(t, predIndex)

	case 11:
		var t *PrimaryTypeContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryTypeContext)
		}
		return p.PrimaryType_Sempred(t, predIndex)

	case 22:
		var t *ArrayTypeContext = nil
		if localctx != nil {
			t = localctx.(*ArrayTypeContext)
		}
		return p.ArrayType_Sempred(t, predIndex)

	case 57:
		var t *DecoratorMemberExpressionContext = nil
		if localctx != nil {
			t = localctx.(*DecoratorMemberExpressionContext)
		}
		return p.DecoratorMemberExpression_Sempred(t, predIndex)

	case 73:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 75:
		var t *IterationStatementContext = nil
		if localctx != nil {
			t = localctx.(*IterationStatementContext)
		}
		return p.IterationStatement_Sempred(t, predIndex)

	case 77:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 78:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 79:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 80:
		var t *YieldStatementContext = nil
		if localctx != nil {
			t = localctx.(*YieldStatementContext)
		}
		return p.YieldStatement_Sempred(t, predIndex)

	case 88:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 127:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 143:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *TypeScriptParser) UnionOrIntersectionOrPrimaryType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) PrimaryType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 3:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ArrayType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) DecoratorMemberExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.NotOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) IterationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.P("of")

	case 8:
		return p.P("of")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) YieldStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.NotLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 29)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 28)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 45)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 44)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 41)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 40)

	case 33:
		return p.NotLineTerminator()

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 39)

	case 35:
		return p.NotLineTerminator()

	case 36:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 37:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return p.LineTerminatorAhead()

	case 39:
		return p.CloseBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
